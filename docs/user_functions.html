<!DOCTYPE html><html lang='en'>
<head>
<title>user_functions.html</title><link rel='stylesheet' href='./user_functions.css' /><body>
<span class = 'filename'>modeller.py</span><br><pre class ='docstring content'>This file is part of the &quot;NECBOL Plain Language Python NEC Runner&quot;
Copyright (c) 2025 Alan Robinson G1OJS

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</pre>
<hr><div><span class ='class signature'>class GeometryObject:</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsp__init__(self, wires):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspadd_wire(self, iTag, nS, x1, y1, z1, x2, y2, z2, wr):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspget_wires(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsptranslate(self, **params):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsprotate_ZtoY(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsprotate_ZtoX(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsprotate_around_Z(self, angle_deg):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsprotate_around_X(self, angle_deg):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsprotate_around_Y(self, angle_deg):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspcos_sin(self,angle_deg):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsprotate(self, R):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspconnect_ends(self, other, tol=1e-3, verbose = False):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsppoint_should_connect_to_wire(self,P, wire, tol=1e-3):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsppoint_on_object(self,geom_object, wire_index, alpha_wire):</span></div>
<hr><div><span class ='class signature'>class units:</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsp__init__(self, default_unit: str = "m"):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspfrom_suffixed_dimensions(self, params: dict, whitelist=[]) -> dict:</span></div>
<pre class ='docstring content'>        
        out = {}
        names_seen = []
        for key, value in params.items():
    
            if not isinstance(value, (int, float)):
                continue  # skip nested dicts or other structures

            name = key
            suffix = &quot;&quot;
            if &quot;_&quot; in name:
                name, suffix = name.rsplit(&quot;_&quot;, 1)
                
            if(name in names_seen):
                warnstr = f&quot;Duplicate value of &#x27;{name}&#x27; seen: ignoring latest ({key} = {value})&quot;
                warnings.warn(warnstr)
                continue

            names_seen.append(name)

            if suffix in self._UNIT_FACTORS:
                # Convert value, output key with &#x27;_m&#x27; suffix
                out[name + &quot;_m&quot;] = value / self._UNIT_FACTORS[suffix]
                continue

            if key in whitelist:
                continue
            
            # fallback: no recognised suffix, assume metres
            warnings.warn(f&quot;No recognised units specified for {name}: &#x27;{suffix}&#x27; specified, metres assumed&quot;)
            # output key gets &#x27;_m&#x27; suffix added
            out[name + &quot;_m&quot;] = value

        return out


#=================================================================================
# NEC Wrapper functions for writing .nec file and reading output
#=================================================================================

</pre>
<hr><div><span class ='class signature'>class NECModel:</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsp__init__(self, working_dir, nec_exe_path, model_name = "Unnamed_Antennna", verbose=False):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspset_name(self, name):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspwrite_runner_files(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspset_wire_conductivity(self, sigma):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspset_frequency(self, MHz):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspset_gain_point(self, azimuth, elevation):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspset_gain_az_arc(self, azimuth_start, azimuth_stop, nPoints, elevation):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspset_ground(self, eps_r, sigma, **params):</span></div>
<pre class ='docstring content'>        if eps_r == 1.0:
            self.GE_CARD = &quot;GE 0\n&quot;
            self.GN_CARD = &quot;&quot;
            self.GM_CARD = &quot;GM 0 0 0 0 0 0 0 0.000\n&quot;
        else:
            origin_height_m = self.units.from_suffixed_dimensions(params)[&#x27;origin_height_m&#x27;]
            self.GE_CARD = &quot;GE -1\n&quot;
            self.GN_CARD = f&quot;GN 2 0 0 0 {eps_r:.3f} {sigma:.3f} \n&quot;
            self.GM_CARD = f&quot;GM 0 0 0 0 0 0 0 {origin_height_m:.3f}\n&quot;

</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspstart_geometry(self, comments="No comments specified"):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspplace_series_RLC_load(self, geomObj, R_ohms, L_uH, C_pf, load_alpha_object=-1, load_wire_index=-1, load_alpha_wire=-1):</span></div>
<pre class ='docstring content'>        self.LOADS.append(f&quot;LD 0 {self.LOAD_iTag} 0 0 {R_ohms} {L_uH * 1e-6} {C_pf * 1e-12}\n&quot;)
        self._place_feed_or_load(geomObj, self.LOAD_iTag, load_alpha_object, load_wire_index, load_alpha_wire)
        self.LOAD_iTag +=1
        
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspplace_parallel_RLC_load(self, geomObj, R_ohms, L_uH, C_pf, load_alpha_object=-1, load_wire_index=-1, load_alpha_wire=-1):</span></div>
<pre class ='docstring content'>        self.LOADS.append(f&quot;LD 1 {self.LOAD_iTag} 0 0 {R_ohms} {L_uH * 1e-6} {C_pf * 1e-12}\n&quot;)
        self._place_feed_or_load(geomObj, self.LOAD_iTag, load_alpha_object, load_wire_index, load_alpha_wire)
        self.LOAD_iTag +=1

</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspplace_feed(self,  geomObj, feed_alpha_object=-1, feed_wire_index=-1, feed_alpha_wire=-1):</span></div>
<pre class ='docstring content'>        self._place_feed_or_load(geomObj, self.EX_TAG, feed_alpha_object, feed_wire_index, feed_alpha_wire)

</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsp_place_feed_or_load(self, geomObj, item_iTag, item_alpha_object, item_wire_index, item_alpha_wire):</span></div>
<pre class ='docstring content'>        wires = geomObj.get_wires()
        if(item_alpha_object &gt;=0):
            item_wire_index = min(len(wires)-1,int(item_alpha_object*len(wires))) # 0 to nWires -1
            item_alpha_wire = item_alpha_object - item_wire_index
        w = wires[item_wire_index]       

        # calculate wire length vector AB, length a to b and distance from a to feed point
        A = np.array(w[&quot;a&quot;], dtype=float)
        B = np.array(w[&quot;b&quot;], dtype=float)
        AB = B-A
        wLen = np.linalg.norm(AB)
        feedDist = wLen * item_alpha_wire

        if (wLen &lt;= self.segLength_m):
            # feed segment is all of this wire, so no need to split
            w[&#x27;nS&#x27;] = 1
            w[&#x27;iTag&#x27;] = item_iTag
        else:
            # split the wire AB into three wires: A to C, CD (feed segment), D to B
            nS1 = int(feedDist / self.segLength_m)              # no need for min of 1 as we always have the feed segment
            C = A + AB * (nS1 * self.segLength_m) / wLen        # feed segment end a
            D = A + AB * ((nS1+1) * self.segLength_m) / wLen    # feed segment end b
            nS2 = int((wLen-feedDist) / self.segLength_m)       # no need for min of 1 as we always have the feed segment
            # write results back to geomObj: modify existing wire to end at C, add feed segment CD and final wire DB
            # (nonzero nS field is preserved during segmentation in &#x27;add&#x27;)
            w[&#x27;b&#x27;] = tuple(C)
            w[&#x27;nS&#x27;] = nS1
            geomObj.add_wire(item_iTag , 1, *C, *D, w[&quot;wr&quot;])
            geomObj.add_wire(w[&quot;iTag&quot;] , nS2, *D, *B, w[&quot;wr&quot;])
            
                
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspadd(self, geomObj):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspwrite_nec(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsprun_nec(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspgains(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsph_gain(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspv_gain(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsptot_gain(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspvswr(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspread_radiation_pattern(self):</span></div>
<span class = 'filename'>optimisers.py</span><br><pre class ='docstring content'>This file is part of the &quot;NECBOL Plain Language Python NEC Runner&quot;
Copyright (c) 2025 Alan Robinson G1OJS

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</pre>
<hr><div><span class ='class signature'>class RandomOptimiser:</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsp__init__(self, build_fn, param_init, cost_fn,</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspformat_params(self, params):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspsame_line_print(self,text):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsprandom_variation(self, x):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspoptimise(self, model,  verbose=False, tty=True):</span></div>
<span class = 'filename'>gui.py</span><br><pre class ='docstring content'>This file is part of the &quot;NECBOL Plain Language Python NEC Runner&quot;
Copyright (c) 2025 Alan Robinson G1OJS

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspshow_wires(wires, ex_tag, title, color='blue'):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspshow_wires_from_file(file_path, ex_tag, color='blue', title = "3D Viewer"):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspplot_gain(pattern_data, elevation_deg, component, polar=True):</span></div>
<span class = 'filename'>components.py</span><br><pre class ='docstring content'>This file is part of the &quot;NECBOL Plain Language Python NEC Runner&quot;
Copyright (c) 2025 Alan Robinson G1OJS

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</pre>
<hr><div><span class ='class signature'>class components:</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsp__init__(self, starting_tag_nr = 0):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspnew_geometry_object(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspcopy_of(self, existing_obj):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspwire_Z(self, **dimensions):</span></div>
<pre class ='docstring content'>        Create a straight wire aligned along the Z-axis, centered at the origin.

        The wire extends from -length/2 to +length/2 on the Z-axis, with the specified diameter.

        dimensions:
            length_{units_string} (float): Length of the wire. 
            wire_diameter_{units_string} (float): Diameter of the wire.
            In each case, the unit suffix (e.g., _mm, _m) must be present in the units class dictionary &#x27;_UNIT_FACTORS&#x27; (see units.py)
        Returns:
            obj (GeometryObject): The constructed geometry object with the defined wire.
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsprect_loop_XZ(self, **dimensions):</span></div>
<pre class ='docstring content'>        Create a rectangular wire loop in the XZ plane, centered at the origin, with the specified wire diameter.
        The &#x27;side&#x27; wires extend from Z=-length/2 to Z=+length/2 at X = +/- width/2.
        The &#x27;top/bottom&#x27; wires extend from X=-width/2 to X=+width/2 at Z = +/- length/2.
        dimensions:
            length_{units_string} (float): &#x27;Length&#x27; (extension along Z) of the rectangle. 
            width_{units_string} (float): &#x27;Width&#x27; (extension along X) of the rectangle. 
            wire_diameter_{units_string} (float): Diameter of the wires.
            In each case, the unit suffix (e.g., _mm, _m) must be present in the units class dictionary &#x27;_UNIT_FACTORS&#x27; (see units.py)
        Returns:
            obj (GeometryObject): The constructed geometry object with the defined wires.
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspconnector(self, from_object, from_wire_index, from_alpha_wire, to_object, to_wire_index, to_alpha_wire,  wire_diameter_mm = 1.0):</span></div>
<pre class ='docstring content'>        Create a single wire from a specified point on the from_object to a specified point on the to_object.
        The point on an object is specified as {ftom|to}_wire_index AND {ftom|to}_alpha_wire, which specify respectively:
              the i&#x27;th wire in the n wires in the object, and
              the distance along that wire divided by that wire&#x27;s length
        Arguments:
            from_object (GeometryObject), from_wire_index (int, 0 .. n_wires_in_from_object - 1), from_alpha_wire (float, 0 .. 1)
            to_object (GeometryObject), to_wire_index (int, 0 .. n_wires_in_to_object - 1), to_alpha_wire (float, 0 .. 1)
        Returns:
            obj (GeometryObject): The constructed geometry object with the defined wire.
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsphelix(self,  wires_per_turn, sense, **dimensions):</span></div>
<pre class ='docstring content'>        Create a single helix with axis = Z axis
        Arguments_
            sense (&quot;LH&quot;|&quot;RH&quot;) - the handedness of the helix          
            wires_per_turn (int) - the number of wires to use to represent the helix, per turn
            dimensions:
                radius_{units} (float) - helix radius 
                length_{units} (float) - helix length along Z 
                pitch_{units} (float)  - helix length along Z per whole turn
                wire_diameter_{units} (float) - diameter of wire making the helix
                In each case above, the units suffix (e.g., _mm, _m) must be present in the units class dictionary &#x27;_UNIT_FACTORS&#x27; (see units.py)
        Returns:
            obj (GeometryObject): The constructed geometry object representing the helix.
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspflexi_helix(self, sense, wires_per_turn, n_cos,r_cos_params,p_cos_params, **dimensions):</span></div>
<pre class ='docstring content'>        Create a helix along the Z axis where radius and pitch vary as scaled sums of cosines:

            r(Z) = r0 * Σ [RA_i * cos(i * π * Z / l + RP_i)] for i=0..n-1
            p(Z) = p0 * Σ [PA_i * cos(i * π * Z / l + PP_i)] for i=0..n-1

        The geometry is generated by stepping through helical phase (φ), and computing local radius and pitch from cosine series 
        as functions of normalized φ (mapped to Z via cumulative pitch integration).

        Parameters:
            sense (str): &quot;RH&quot; or &quot;LH&quot; handedness
            wires_per_turn (int): Resolution (segments per full turn)
            n_cos (int): Number of cosine terms
            r_cos_params (list of tuples): [(RA0, RP0), ...] radius amplitudes and phases
            p_cos_params (list of tuples): [(PA0, PP0), ...] pitch amplitudes and phases
            dimensions:
                l_{units} (float): Approximate helix length along Z
                r0_{units} (float): Base radius scale factor
                p0_{units} (float): Base pitch scale factor (length per full turn)
                wire_diameter_{units} (float): Wire thickness

        Returns:
            GeometryObject: The constructed helix geometry object.
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspcosine_series(s, terms):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspcircular_arc(self, n_wires, arc_phi_deg, **dimensions):</span></div>
<pre class ='docstring content'>        Create a single circular arc in the XY plane centred on the origin
        Arguments:
            n_wires (int) - the number of wires to use to represent the arc         
            arc_phi_deg (float) - the angle subtended at the origin by the arc in degrees. Note that a continuous circular loop can be constructed by specifying arc_phi_deg = 360.
            dimensions:
                radius_{units} (float) - helix radius 
                wire_diameter_{units} (float) - diameter of wire making the helix
                In each case above, the units suffix (e.g., _mm, _m) must be present in the units class dictionary &#x27;_UNIT_FACTORS&#x27; (see units.py)
        Returns:
            obj (GeometryObject): The constructed geometry object representing the helix.
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspthin_sheet(self, model, sigma, epsillon_r, force_odd = True,</span></div>
<pre class ='docstring content'>        Creates a grid of wires interconnected at segment level to economically model a flat sheet
        which is normal to the x axis and extends from z=-height/2 to z= height/2, and y = -length/2 to length/2
        Models *either* conductive or dielectric sheet, not both.
        Set epsillon_r to 1.0 for conductive sheet
        Set epsillon_r &gt; 1.0 for dielectric sheet (conductivity value is then not used)

        Arguments:
            model - the object model being built
            sigma - conductivity in mhos/metre
            epsillon_r - relative dielectric constant
            force_odd = true ensures wires cross at y=z=0
            The four &#x27;close_&#x27; parameters determine whether or not the edges are &#x27;sealed&#x27; with a final wire (if True) or
            not (if False) so that the grid can be joined to other grids without wires overlapping:
                close_end = True completes the grid with a final end z wire at y = length/2 
                close_start = True starts the grid with a z wire at y = -length/2 
                close_top = True completes the grid with a y wire at z = height/2 
                close_bottom = True starts the grid with a y wire at z = -height/2 
            enforce_exact_pitch: if True, length and height are adjusted to fit an integer number
            of grid cells of the specified pitch. If False, length and height remain as specified and
            the grid pitch in Y and Z is adjusted to fit the number of grid cells calculated from the
            grid pitch and force_odd value. Behaviour prior to V2.0.3 was enforce_exact_pitch.

        Dimensions are length_, height_, thickness_, grid_pitch_
</pre>

<br><br><span style = 'font-size:0.8em;color:#666;border-top:1px solid #ddd; font-style:italic'>Made with Docu-lite v0.7.4 by Alan Robinson: github.com/G1OJS/docu-lite/</span></body>
