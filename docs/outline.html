<!DOCTYPE html><html lang='en'>
<head>
<title>outline.html</title><link rel='stylesheet' href='./outline.css' /><body>
<br><div class = 'filename'>__init__.py</div><br><br><div class = 'filename'>modeller.py</div><br><details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>import numpy as np
import math
import warnings
import subprocess
import os

#=================================================================================
# The geometry object that holds a single component plus its methods
#=================================================================================

</pre>
</details>
<details><summary><span class ='class signature'> class GeometryObject:</span></summary>
<pre class ='class content'></pre>
<details><summary><span class ='def signature'> def __init__(self, wires):</span></summary>
<pre class ='def content'>        self.wires = wires  # list of wire dicts with iTag, nS, x1, y1, ...
        self._units = _units()

</pre>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def translate(self, **params):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Translate an object by dx, dy, dz
            Arguments are dx_{units}, dy_{units}, dz_{units}
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        params_m = self._units._from_suffixed_dimensions(params)
        for w in self.wires:
            w[&#x27;a&#x27;] = tuple(map(float,np.array(w[&#x27;a&#x27;]) + np.array([params_m.get(&#x27;dx_m&#x27;), params_m.get(&#x27;dy_m&#x27;), params_m.get(&#x27;dz_m&#x27;)])))
            w[&#x27;b&#x27;] = tuple(map(float,np.array(w[&#x27;b&#x27;]) + np.array([params_m.get(&#x27;dx_m&#x27;), params_m.get(&#x27;dy_m&#x27;), params_m.get(&#x27;dz_m&#x27;)])))

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def rotate_ZtoY(self):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Rotate the object through 90 degrees around X
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        R = np.array([[1, 0, 0],[0,  0, 1],[0,  -1, 0]])
        return self._rotate(R)
    
</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def rotate_ZtoX(self):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Rotate the object through 90 degrees around Y
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        R = np.array([[0, 0, 1],[0,  1, 0],[-1,  0, 0]])
        return self._rotate(R)

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def rotate_around_X(self, angle_deg):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Rotate the object through angle_deg degrees around X
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        ca, sa = self._cos_sin(angle_deg)
        R = np.array([[1, 0, 0],
                      [0, ca, -sa],
                      [0, sa, ca]])
        return self._rotate(R)

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def rotate_around_Y(self, angle_deg):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Rotate the object through angle_deg degrees around Y
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        ca, sa = self._cos_sin(angle_deg)
        R = np.array([[ca, 0, sa],
                      [0, 1, 0],
                      [-sa, 0, ca]])
        return self._rotate(R)

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def rotate_around_Z(self, angle_deg):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Rotate the object through angle_deg degrees around Z
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        ca, sa = self._cos_sin(angle_deg)
        R = np.array([[ca, -sa, 0],
                      [sa, ca, 0],
                      [0, 0, 1]])
        return self._rotate(R)

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def connect_ends(self, other, tol=1e-3, verbose = False):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Check both ends of the wire to see if they lie on any wires in the specified object,
            and if so, split the wires of the specified object so that NEC considers them to be
            a valid T junction. Usage is:

            wire.connect_ends(object, [tol in m], [verbose])

            if verbose is True, details of the wire connection(s) are printed
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        wires_to_add=[]
        for ws in self.wires:
            if(verbose):
                print(f&quot;\nChecking if ends of wire from {ws[&#x27;a&#x27;]} to {ws[&#x27;b&#x27;]} should connect to any of {len(other.wires)} other wires:&quot;)
            for es in [ws[&quot;a&quot;], ws[&quot;b&quot;]]:
                for wo in other.wires:
                    if (self._point_should_connect_to_wire(es,wo,tol)):
                        wire_seg_status = f&quot;{wo[&#x27;nS&#x27;]} segment&quot; if wo[&#x27;nS&#x27;] &gt; 0 else &#x27;unsegmented&#x27;
                        length_orig = np.linalg.norm(np.array(wo[&quot;a&quot;]) - np.array(wo[&quot;b&quot;]))
                        b_orig = wo[&quot;b&quot;]
                        wo[&#x27;b&#x27;]=tuple(es)
                        length_shortened = np.linalg.norm(np.array(wo[&quot;a&quot;]) - np.array(wo[&quot;b&quot;]))
                        nS_shortened = max(1, int(wo[&#x27;nS&#x27;]*length_shortened/length_orig))
                        nS_orig = wo[&#x27;nS&#x27;]
                        wo[&#x27;nS&#x27;] = nS_shortened
                        nS_remainder = max(1,nS_orig - nS_shortened)
                        wires_to_add.append( (wo[&#x27;iTag&#x27;], nS_remainder, *wo[&#x27;b&#x27;], *b_orig, wo[&#x27;wr&#x27;]) )
                        length_remainder = np.linalg.norm(np.array(wo[&quot;b&quot;]) - np.array(b_orig))
                        if(verbose):
                            print(f&quot;Inserting end of wire at {wo[&#x27;b&#x27;]} into {wire_seg_status} wire {length_orig}m wire from {wo[&#x27;a&#x27;]} to {b_orig}:&quot;)
                            print(f&quot;    by shortening wire to end at {wo[&#x27;b&#x27;]}: {length_shortened}m, using {nS_shortened} segments&quot;)
                            print(f&quot;    and adding wire from {wo[&quot;b&quot;]} to {b_orig}:  {length_remainder}m using {nS_remainder} segments&quot;)
                        break #(for efficiency only)
        for params in wires_to_add:
            other._add_wire(*params)

#===============================================================
# internal functions for class GeometryObject
#===============================================================

</pre>
</details>
</details>
<details><summary><span class ='def signature'> def _cos_sin(self,angle_deg):</span></summary>
<pre class ='def content'>        angle_rad = math.pi*angle_deg/180
        ca = math.cos(angle_rad)
        sa = math.sin(angle_rad)
        return ca, sa
    
</pre>
</details>
<details><summary><span class ='def signature'> def _rotate(self, R):</span></summary>
<pre class ='def content'>        for w in self.wires:
            a = np.array(w[&#x27;a&#x27;])
            b = np.array(w[&#x27;b&#x27;])
            w[&#x27;a&#x27;] = tuple(map(float, R @ a))
            w[&#x27;b&#x27;] = tuple(map(float, R @ b))

</pre>
</details>
<details><summary><span class ='def signature'> def _add_wire(self, iTag, nS, x1, y1, z1, x2, y2, z2, wr):</span></summary>
<pre class ='def content'>        self.wires.append({&quot;iTag&quot;:iTag, &quot;nS&quot;:nS, &quot;a&quot;:(x1, y1, z1), &quot;b&quot;:(x2, y2, z2), &quot;wr&quot;:wr})

</pre>
</details>
<details><summary><span class ='def signature'> def _get_wires(self):</span></summary>
<pre class ='def content'>        return self.wires

</pre>
</details>
<details><summary><span class ='def signature'> def _point_should_connect_to_wire(self,P, wire, tol=1e-3):</span></summary>
<pre class ='def content'>        P = np.array(P, dtype=float)
        A = np.array(wire[&#x27;a&#x27;], dtype=float)
        B = np.array(wire[&#x27;b&#x27;], dtype=float)
        AB = B - A
        AP = P - A
        AB_len = np.linalg.norm(AB)
        # can&#x27;t connect to a zero length wire using the splitting method
        if AB_len == 0:
            return False
        
        # Check perpendicular distance from wire axis
        # if we aren&#x27;t close enough to the wire axis to need to connect, return false
        # NOTE: need to align tol with nec&#x27;s check of volumes intersecting
        perp_dist = np.linalg.norm(np.cross(AP, AB)) / AB_len
        if perp_dist &gt; tol: 
            return False    

        # Project point onto the wire to get fractional position
        alpha = np.dot(AP, AB) / (AB_len**2)
        if not (0 &lt;= alpha &lt;= 1):
            return False  # point is on the wire axis but not between the wire ends

        # If we are within allowable tolerance of the wire ends, don&#x27;t split the wire
        dist_from_end = min(alpha*AB_len, (1-alpha)*AB_len)
        if (dist_from_end &lt; tol):
            return False

        # IF the wire is already segmented (e.g. in a grid), check how far from the
        # *nearest* segment boundary this projected alpha is
        if(wire[&#x27;nS&#x27;]&gt;0):
            segment_pitch = 1 / wire[&#x27;nS&#x27;]
            nearest_alpha = round(alpha / segment_pitch) * segment_pitch
            alpha_dist = abs(alpha - nearest_alpha)
            alpha_tol = tol / AB_len  # convert spatial tol to alpha-space
            if alpha_dist &lt; alpha_tol:
                return False  # near a segment end â€” NEC will handle this as a normal junction

        return True  # wire needs to be split to allow the connection

</pre>
</details>
<details><summary><span class ='def signature'> def _point_on_object(self,geom_object, wire_index, alpha_wire):</span></summary>
<pre class ='def content'>        if(wire_index&gt; len(geom_object.wires)):
            wire_index = len(geom_object.wires)
            alpha_wire = 1.0
        w = geom_object.wires[wire_index]
        A = np.array(w[&quot;a&quot;], dtype=float)
        B = np.array(w[&quot;b&quot;], dtype=float)
        P = A + alpha_wire * (B-A)
        return P
         
#=================================================================================
# Units processor
#=================================================================================

</pre>
</details>
</details>
<details><summary><span class ='class signature'> class _units:</span></summary>
<pre class ='class content'></pre>
<details><summary><span class ='def signature'>ðŸ§¾ def _from_suffixed_dimensions(self, params: dict, whitelist=[]) -> dict:</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>        Converts suffixed values like &#x27;d_mm&#x27; to meters.

        Output keys have &#x27;_m&#x27; suffix unless they already end with &#x27;_m&#x27;,
        in which case they are passed through unchanged (assumed meters).
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        _UNIT_FACTORS = {
        &quot;m&quot;: 1.0,
        &quot;mm&quot;: 1000.0,
        &quot;cm&quot;: 100.0,
        &quot;in&quot;: 39.3701,
        &quot;ft&quot;: 3.28084,
        }

        out = {}
        names_seen = []
        for key, value in params.items():
    
            if not isinstance(value, (int, float)):
                continue  # skip nested dicts or other structures

            name = key
            suffix = &quot;&quot;
            if &quot;_&quot; in name:
                name, suffix = name.rsplit(&quot;_&quot;, 1)
                
            if(name in names_seen):
                warnstr = f&quot;Duplicate value of &#x27;{name}&#x27; seen: ignoring latest ({key} = {value})&quot;
                warnings.warn(warnstr)
                continue

            names_seen.append(name)

            if suffix in _UNIT_FACTORS:
                # Convert value, output key with &#x27;_m&#x27; suffix
                out[name + &quot;_m&quot;] = value / _UNIT_FACTORS[suffix]
                continue

            if key in whitelist:
                continue
            
            # fallback: no recognised suffix, assume metres
            warnings.warn(f&quot;No recognised units specified for {name}: &#x27;{suffix}&#x27; specified, metres assumed&quot;)
            # output key gets &#x27;_m&#x27; suffix added
            out[name + &quot;_m&quot;] = value

        return out


#=================================================================================
# NEC Wrapper functions for writing .nec file and reading output
#=================================================================================

</pre>
</details>
</details>
</details>
<details><summary><span class ='class signature'> class NECModel:</span></summary>
<pre class ='class content'></pre>
<details><summary><span class ='def signature'> def __init__(self, working_dir, nec_exe_path, model_name = "Unnamed_Antennna", verbose=False):</span></summary>
<pre class ='def content'>        self.verbose = verbose
        self.working_dir = working_dir
        self.nec_exe = nec_exe_path
        self.nec_bat = working_dir + &quot;\\nec.bat&quot;
        self.nec_in = working_dir + &quot;\\&quot; + model_name +  &quot;.nec&quot;
        self.nec_out = working_dir + &quot;\\&quot; + model_name +  &quot;.out&quot;
        self.files_txt = working_dir + &quot;\\files.txt&quot;
        self.model_name = model_name
        self.nSegs_per_wavelength = 40
        self.segLength_m = 0
        self._units = _units()
        self.default_wire_sigma = None
        self.MHz = None
        self.MHz_stop = None
        self.MHz_step = None
        self.segLength_m
        self.az_step_deg = 1
        self.el_step_deg = 1
        self.ground_sigma = 0
        self.ground_Er = 1.0
        self.geometry = []
        self.EX_tag = 999
        self.LOADS = []
        self.LD_start_tag = 8000

</pre>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def set_name(self, name):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Set the name of the model. This is used in NEC input file generation and is reflected in the NEC
            output file name. It is permissible to use this function to re-set the name after a NEC run has completed,
            so that the analysis continues (with updated input parameters) and outputs more than one test case
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        self.model_name = name
        self.nec_in = self.working_dir + &quot;\\&quot; + self.model_name +  &quot;.nec&quot;
        self.nec_out = self.working_dir + &quot;\\&quot; + self.model_name +  &quot;.out&quot;
        self._write_runner_files()

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def set_wire_conductivity(self, sigma):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Set wire conductivity to be assumed for all wires that don&#x27;t have an explicitly-set load.
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        self.default_wire_sigma = sigma
        self.LD_WIRECOND = f&quot;LD 5 0 0 0 {sigma:.6f} \n&quot;

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def set_frequency(self, MHz, MHz_end = None, MHz_step = None):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Request NEC to perform all analysis at the specified frequency. 
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        self.MHz = MHz
        lambda_m = 300/MHz
        self.segLength_m = lambda_m / self.nSegs_per_wavelength
        
</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def set_angular_resolution(self, az_step_deg, el_step_deg):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Set resolution required in az and el in degrees
            If a ground is specified, NEC will be asked for a hemisphere, otherwise a sphere
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        self.az_step_deg = az_step_deg
        self.el_step_deg = el_step_deg

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def set_ground(self, eps_r, sigma, **params):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Sets the ground relative permitivity and conductivity. Currently limited to simple choices.
            If eps_r = 1, nec is told to use no ground (free space model), and you may omit the origin height parameter
            If you don&#x27;t call this function, free space will be assumed.
            Othewise you should set the origin height so that the antenna reference point X,Y,Z = (0,0,0) is set to be
            the specified distance above ground.
            Parameters:
                eps_r (float): relative permittivity (relative dielectric constant) of the ground
                sigma (float): conductivity of the ground in mhos/meter
                origin_height_{units_string} (float): Height of antenna reference point X,Y,Z = (0,0,0)
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'></pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def place_RLC_load(self, geomObj, R_ohms, L_uH, C_pf, load_type = 'Series', load_alpha_object=-1, load_wire_index=-1, load_alpha_wire=-1):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            inserts a single segment containing an RLC load into an existing geometry object
            Position within the object is specied as
            EITHER:
              load_alpha_object (range 0 to 1) as a parameter specifying the length of
                                wire traversed to reach the item by following each wire in the object,
                                divided by the length of all wires in the object
                                (This is intended to be used for objects like circular loops where there
                                are many short wires each of the same length)
            OR:
              load_wire_index AND load_alpha_wire
              which specify the i&#x27;th wire (0 to n-1) in the n wires in the object, and the distance along that
              wire divided by that wire&#x27;s length

            NEC LD card specification: https://www.nec2.org/part_3/cards/ld.html
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        iTag = self.LOADS_start_Tag + len(self.LOADS)
        model.LOADS.append({&#x27;iTag&#x27;: iTag, &#x27;type&#x27;: load_type, &#x27;value&#x27;: (R_Ohms, L_uH * 1e-6, C_pf * 1e-12), &#x27;alpha&#x27;: None})
        self._insert_special_segment(geomObj, iTag, load_alpha_object, load_wire_index, load_alpha_wire)


</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def place_feed(self,  geomObj, feed_alpha_object=-1, feed_wire_index=-1, feed_alpha_wire=-1):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Inserts a single segment containing the excitation point into an existing geometry object.
            Position within the object is specied as
            EITHER:
              feed_alpha_object (range 0 to 1) as a parameter specifying the length of
                                wire traversed to reach the item by following each wire in the object,
                                divided by the length of all wires in the object
                                (This is intended to be used for objects like circular loops where there
                                are many short wires each of the same length)
            OR:
              feed_wire_index AND feed_alpha_wire
              which specify the i&#x27;th wire (0 to n-1) in the n wires in the object, and the distance along that
              wire divided by that wire&#x27;s length
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        self._insert_special_segment(geomObj, self.EX_tag, feed_alpha_object, feed_wire_index, feed_alpha_wire)
   
</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def add(self, geomObj):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Add a completed component to the specified model: model_name.add(component_name). Any changes made
            to the component after this point are ignored.
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        self.geometry.append(geomObj)

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def write_nec(self):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Write the entire model to the NEC input file ready for analysis. At this point, the function
            &quot;show_wires_from_file&quot; may be used to see the specified geometry in a 3D view.
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        self._write_runner_files()
        
        # open the .nec file
        with open(self.nec_in, &quot;w&quot;) as f:
            f.write(&quot;CM\nCE\n&quot;)
            
            # 1. Write GW lines for all geometry
            for geomObj in self.geometry:
                for w in geomObj._get_wires():
                    A = np.array(w[&quot;a&quot;], dtype=float)
                    B = np.array(w[&quot;b&quot;], dtype=float)
                    if(w[&#x27;nS&#x27;] == 0): # calculate and update number of segments only if not already present
                        w[&#x27;nS&#x27;] = 1+int(np.linalg.norm(B-A) / self.segLength_m)
                    f.write(f&quot;GW {w[&#x27;iTag&#x27;]} {w[&#x27;nS&#x27;]} &quot;)
                    f.write(&#x27; &#x27;.join([f&quot;{A[i]:.3f} &quot; for i in range(3)]))
                    f.write(&#x27; &#x27;.join([f&quot;{B[i]:.3f} &quot; for i in range(3)]))
                    f.write(f&quot; {w[&#x27;wr&#x27;]}\n&quot;)

            # 2. Write GE card, Ground Card, and RP card
            if self.ground_Er == 1.0:
                f.write(&quot;GE 0\n&quot;)
            else:
                origin_height_m = self._units._from_suffixed_dimensions(params)[&#x27;origin_height_m&#x27;]
                f.write(&quot;GE -1\n&quot;)
                f.write(f&quot;GN 2 0 0 0 {Er:.3f} {sigma:.3f} \n&quot;)
                f.write(f&quot;GM 0 0 0 0 0 0 0 {origin_height_m:.3f}\n&quot;)

            # 3. Write out the loads
            for LD in self.LOADS:
                LDTYP = [&#x27;series&#x27;,&#x27;parallel&#x27;,&#x27;series_per_metre&#x27;,&#x27;parallel_per_metre&#x27;,&#x27;impedance_not_used&#x27;,&#x27;conductivity&#x27;].indexof(LD[&#x27;load_type&#x27;])
                LDTAG = LD[&#x27;iTag&#x27;]
                # these strings are set programatically so shouldn&#x27;t need an error trap
                f.write(f&quot;LD {LDTYP} {LDTAG} 0 0 {LD[&#x27;R_Ohms&#x27;]} {LD[&#x27;L_uH&#x27;] * 1e-6} {LD[&#x27;C_pf&#x27;] * 1e-12}&quot;)

            # 4. Feed
            f.write(f&quot;EX 0 {self.EX_tag} 1 0 1 0\n&quot;)

            # 5. Frequency
            f.write(f&quot;FR 0 1 0 0 {self.MHz:.3f} 0\n&quot;)

            # 6. Pattern points
            if self.ground_Er == 1.0:
                f.write(&quot;RP 0 181 361 1003 -180 0 1 1\n&quot;)
            else:
                f.write(f&quot;RP 0 91 361 1003 0 0 1 1\n&quot;)
                
            f.write(&quot;EN&quot;)

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def run_nec(self):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Pass the model file to NEC for analysis and wait for the output.
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        subprocess.run([self.nec_bat], creationflags=subprocess.CREATE_NO_WINDOW)

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def h_gain(self):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Return the horizontal polarisation gain at the specified single gain point
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        return self._get_single_point_gains()[&#x27;h_gain&#x27;]

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def v_gain(self):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Return the vertical polarisation gain at the specified single gain point
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        return self._get_single_point_gains()[&#x27;v_gain&#x27;]

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def tot_gain(self):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Return the total gain at the specified single gain point
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        return self._get_single_point_gains()[&#x27;total&#x27;]

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def vswr(self, Z0 = 50):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Return the antenna VSWR at the feed point assuming a 50 ohm system
            Or another value if specified
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        try:
            with open(self.nec_out) as f:
                while &quot;ANTENNA INPUT PARAMETERS&quot; not in f.readline():
                    pass
                for _ in range(4):
                    l = f.readline()
                if self.verbose:
                    print(&quot;Z line:&quot;, l.strip())
                r = float(l[60:72])
                x = float(l[72:84])
        except (RuntimeError, ValueError):
            raise ValueError(f&quot;Something went wrong reading input impedance from {nec_out}&quot;)

        z_in = r + x * 1j
        gamma = (z_in - Z0) / (z_in + Z0)
        return (1 + abs(gamma)) / (1 - abs(gamma))

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def read_radiation_pattern(self):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            read the radiation pattern from the model.nec_out file
            into a list of dictionaries with format:
                {&#x27;theta&#x27;: theta,
                &#x27;phi&#x27;: phi,
                &#x27;gain_vert_db&#x27;: gain_vert,
                &#x27;gain_horz_db&#x27;: gain_horz,
                &#x27;gain_total_db&#x27;: gain_total,
                &#x27;axial_ratio&#x27;: axial_ratio,
                &#x27;tilt_deg&#x27;: tilt_deg,
                &#x27;sense&#x27;: sense,
                &#x27;E_theta_mag&#x27;: e_theta_mag,
                &#x27;E_theta_phase_deg&#x27;: e_theta_phase,
                &#x27;E_phi_mag&#x27;: e_phi_mag,
                &#x27;E_phi_phase_deg&#x27;: e_phi_phase}
                
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        return _read_radiation_pattern(self.nec_out)

#===============================================================
# internal functions for class NECModel
#===============================================================
</pre>
</details>
</details>
<details><summary><span class ='def signature'> def _get_single_point_gains(self):</span></summary>
<pre class ='def content'>        # this will be refactored to call _read_radiation_pattern
        # and store the result, so that if it is called again
        # the read is not needed
        # Also, either using interpolation or aligning a cut / sphere with the
        # needed point may provide efficiencies (and maintainability, more importantly)
        try:
            with open(self.nec_out) as f:
                while &quot;RADIATION PATTERNS&quot; not in f.readline():
                    pass
                for _ in range(5):
                    l = f.readline()
                if self.verbose:
                    print(&quot;Gains line:&quot;, l.strip())
        except (RuntimeError, ValueError):
            raise ValueError(f&quot;Something went wrong reading gains from {nec_out}&quot;)

        return {
            &quot;v_gain&quot;: float(l[21:29]),
            &quot;h_gain&quot;: float(l[29:37]),
            &quot;total&quot;: float(l[37:45]),
        }


</pre>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def _write_runner_files(self):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            Write the .bat file to start NEC, and &#x27;files.txt&#x27; to tell NEC the name of the input and output files
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        for filepath, content in [
            (self.nec_bat, f&quot;{self.nec_exe} &lt; {self.files_txt} \n&quot;),
            (self.files_txt, f&quot;{self.nec_in}\n{self.nec_out}\n&quot;)
        ]:
            directory = os.path.dirname(filepath)
            if directory and not os.path.exists(directory):
                os.makedirs(directory)  # create directory if it doesn&#x27;t exist
            try:
                with open(filepath, &quot;w&quot;) as f:
                    f.write(content)
            except Exception as e:
                print(f&quot;Error writing file {filepath}: {e}&quot;)

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def _insert_special_segment(self, geomObj, item_iTag, item_alpha_object, item_wire_index, item_alpha_wire):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            inserts a single segment with a specified iTag into an existing geometry object
            position within the object is specied as either item_alpha_object or item_wire_index, item_alpha_wire
            (see calling functions for more details)
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        wires = geomObj._get_wires()
        if(item_alpha_object &gt;=0):
            item_wire_index = min(len(wires)-1,int(item_alpha_object*len(wires))) # 0 to nWires -1
            item_alpha_wire = item_alpha_object - item_wire_index
        w = wires[item_wire_index]       

        # calculate wire length vector AB, length a to b and distance from a to feed point
        A = np.array(w[&quot;a&quot;], dtype=float)
        B = np.array(w[&quot;b&quot;], dtype=float)
        AB = B-A
        wLen = np.linalg.norm(AB)
        feedDist = wLen * item_alpha_wire

        if (wLen &lt;= self.segLength_m):
            # feed segment is all of this wire, so no need to split
            w[&#x27;nS&#x27;] = 1
            w[&#x27;iTag&#x27;] = item_iTag
        else:
            # split the wire AB into three wires: A to C, CD (feed segment), D to B
            nS1 = int(feedDist / self.segLength_m)              # no need for min of 1 as we always have the feed segment
            C = A + AB * (nS1 * self.segLength_m) / wLen        # feed segment end a
            D = A + AB * ((nS1+1) * self.segLength_m) / wLen    # feed segment end b
            nS2 = int((wLen-feedDist) / self.segLength_m)       # no need for min of 1 as we always have the feed segment
            # write results back to geomObj: modify existing wire to end at C, add feed segment CD and final wire DB
            # (nonzero nS field is preserved during segmentation in &#x27;add&#x27;)
            w[&#x27;b&#x27;] = tuple(C)
            w[&#x27;nS&#x27;] = nS1
            geomObj._add_wire(item_iTag , 1, *C, *D, w[&quot;wr&quot;])
            geomObj._add_wire(w[&quot;iTag&quot;] , nS2, *D, *B, w[&quot;wr&quot;])
            

</pre>
</details>
</details>
</details>
<details><summary><span class ='def signature'> def _read_radiation_pattern(filepath):</span></summary>
<pre class ='def content'>    data = []
    in_data = False
    start_lineNo = 1e9
    with open(filepath) as f:
        lines = f.readlines()
    for lineNo, line in enumerate(lines):
        if (&#x27;RADIATION PATTERNS&#x27; in line):
            in_data = True
            start_lineNo = lineNo + 5

        if (lineNo &gt; start_lineNo and line==&quot;\n&quot;):
            in_data = False
            
        if (in_data and lineNo &gt;= start_lineNo):
            theta = float(line[0:9])
            phi = float(line[9:18])
            gain_vert = float(line[18:28])
            gain_horz = float(line[28:36])
            gain_total = float(line[36:45])
            axial_ratio = float(line[45:55])
            tilt_deg = float(line[55:63])
            # SENSE is a string (LINEAR, LHCP, RHCP, etc.)
            sense = line[63:72].strip()
            e_theta_mag = float(line[72:87])
            e_theta_phase = float(line[87:96])
            e_phi_mag = float(line[96:111])
            e_phi_phase = float(line[111:119])

            data.append({
                &#x27;theta&#x27;: theta,
                &#x27;phi&#x27;: phi,
                &#x27;gain_vert_db&#x27;: gain_vert,
                &#x27;gain_horz_db&#x27;: gain_horz,
                &#x27;gain_total_db&#x27;: gain_total,
                &#x27;axial_ratio&#x27;: axial_ratio,
                &#x27;tilt_deg&#x27;: tilt_deg,
                &#x27;sense&#x27;: sense,
                &#x27;E_theta_mag&#x27;: e_theta_mag,
                &#x27;E_theta_phase_deg&#x27;: e_theta_phase,
                &#x27;E_phi_mag&#x27;: e_phi_mag,
                &#x27;E_phi_phase_deg&#x27;: e_phi_phase
            })


    return data


</pre>
</details>
<br><div class = 'filename'>optimisers.py</div><br><details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>
import random, sys

</pre>
</details>
<details><summary><span class ='class signature'>ðŸ§¾ class RandomOptimiser:</span></summary>
<pre class ='class content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>        Initialise the optimisation parameters. Details to be written - please see examples for help with parameters.
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'></pre>
</details>
<details><summary><span class ='def signature'> def __init__(self, build_fn, param_init, cost_fn, bounds={}, delta_init=0.2, stall_limit=50, max_iter=250, min_delta=0.001):</span></summary>
<pre class ='def content'>        self.build_fn = build_fn
        self.param_names = list(param_init.keys())
        self.x_baseline = param_init.copy()
        self.bounds = bounds
        self.cost_fn = cost_fn
        self.delta_x = delta_init
        self.min_delta = min_delta
        self.stall_limit = stall_limit
        self.max_iter = max_iter

</pre>
</details>
<details><summary><span class ='def signature'> def _format_params(self, params):</span></summary>
<pre class ='def content'>        s=&quot;{&quot;
        for k, v in params.items():
            s = s + f&quot;&#x27;{k}&#x27;: {v:.2f}, &quot;
        return s[0:-2]+&quot;}&quot;

</pre>
</details>
<details><summary><span class ='def signature'> def _same_line_print(self,text):</span></summary>
<pre class ='def content'>        sys.stdout.write(f&quot;\r{text}          &quot;)
        sys.stdout.flush()

</pre>
</details>
<details><summary><span class ='def signature'> def _random_variation(self, x):</span></summary>
<pre class ='def content'>        x_new = x.copy()
        for name in self.param_names:
            factor = 1 + random.uniform(-self.delta_x, self.delta_x)
            val = x[name] * factor
            x_new[name] = val
            if(name in self.bounds):
                minv, maxv = self.bounds[name]
                x_new[name] = max(min(x_new[name], maxv), minv)
        return x_new

</pre>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def optimise(self, model,  verbose=False, tty=True):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>            This random optimiser works by simultaneously adjusting all input parameters by a random multiplier (1 + x)
            and comparing the user-specified cost function with the best achieved so far. If the test gives a better
            cost, the test is adopted as the new baseline.

            Note that of course this won&#x27;t produce good results for any parameters that start off close to or at
            zero and/or have an allowable range with zero close to the middle. Future versions of this optimiser may allow
            specifications to make this work, but for now you should arrange for the input parameters and their
            likely useful range to be away from zero, by using an offset.

            If any parameters seem likely to drift into non-useful ranges, use the &#x27;bounds&#x27; specification in the
            initialisation to limit their max and min values.
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        best_params = self.x_baseline.copy()
        best_model = self.build_fn(model, **best_params)
        best_model.write_nec()
        best_model.run_nec()
        result = self.cost_fn(best_model)
        best_cost = result[&#x27;cost&#x27;]
        best_info = result[&#x27;info&#x27;]
        stall_count = 0
        print(&quot;\nSTARTING optimiser. Press CTRL-C to stop&quot;)
        initial_message = f&quot;[] INITIAL: {best_info} with {self._format_params(best_params)}&quot;
        print(initial_message)

        try:
            for i in range(self.max_iter):
                test_params = self._random_variation(best_params)
                test_model = self.build_fn(model, **test_params)
                test_model.write_nec()
                test_model.run_nec()
                result = self.cost_fn(test_model)
                test_cost = result[&#x27;cost&#x27;]
                test_info = result[&#x27;info&#x27;]

                if test_cost &lt; best_cost:
                    best_cost = test_cost
                    best_params = test_params
                    best_info = test_info
                    stall_count = 0
                    if(not tty):
                        print(&quot;&quot;)
                    self._same_line_print(f&quot;[{i}] IMPROVED: {best_info} with {self._format_params(best_params)}&quot;)
                    print(&quot;&quot;)
                else:
                    stall_count += 1
                    if(tty):
                        self._same_line_print(f&quot;[{i}] {test_info}&quot;)
                    else:
                        sys.stdout.write(&quot;.&quot;)

                if stall_count &gt;= self.stall_limit:
                    self.delta_x /= 2
                    if(self.delta_x &lt; self.min_delta):
                        if(not tty):
                            print(&quot;&quot;)
                        self._same_line_print(f&quot;[{i}] Delta below minimum&quot;)
                        print(&quot;&quot;)
                        break
                    stall_count = 0
                    if(not tty):
                        print(&quot;&quot;)
                    self._same_line_print(f&quot;[{i}] STALLED: Reducing delta to {self.delta_x}&quot;)
                    print(&quot;&quot;)

        except KeyboardInterrupt:
            print(&quot;\nINTERRUPTED by user input&quot;)
            
        best_model = self.build_fn(model, **best_params)
        best_model.write_nec()
        best_model.run_nec()
        result = self.cost_fn(best_model)
        final_info = result[&#x27;info&#x27;]
        print(&quot;\nFINISHED optimising\n&quot;)
        print(&quot;# Optimiser Results (copy and paste into your antenna file for reference). \nNote that you can copy the information between the {} to paste in as your new starting parameters.)&quot;)
        print(&quot;# &quot;+ initial_message)
        print(f&quot;# []   FINAL: {final_info} with {self._format_params(best_params)}&quot;)
        
        return best_params, final_info
</pre>
</details>
</details>
</details>
<br><div class = 'filename'>gui.py</div><br><details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'></pre>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def show_wires_from_file(file_path, ex_tag, color='blue', title = "3D Viewer"):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>        Opens the specified nec input file (*.nec) and reads the geometry,
        then displays the geometry in a 3D projection. The feed is highligted in red.
        Loads are highlighted in green.
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>    wires = []
    with open(file_path, &#x27;r&#x27;) as f:
        for line in f:
            if line.startswith(&quot;GW&quot;):
                parts = line.strip().split()
                if len(parts) &gt;= 9:
                    # NEC input is: GW tag seg x1 y1 z1 x2 y2 z2 radius
                    x1, y1, z1 = map(float, parts[3:6])
                    x2, y2, z2 = map(float, parts[6:9])
                    tag = int(parts[1])
                    wires.append(((x1, y1, z1), (x2, y2, z2), tag))
    _show_wires(wires, ex_tag, title, color=color)

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def plot_gain(pattern_data, elevation_deg, component, polar=True):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>        This is a very basic plot routine providing polar and rectangular plots
        with gain range covering 40 dB max to min.
        Later versions of necbol will include more customisable plot functions
        and the ability to save output data in a suitable format for onward analysis
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>    import matplotlib.pyplot as plt
    import numpy as np
        
    # Filter data for fixed elevation (theta)
    theta_cut = 90 - elevation_deg
    print(f&quot;Plotting gain for elevation = {elevation_deg} i.e. theta = {theta_cut}&quot;)
    az_cut = [d for d in pattern_data if abs(d[&#x27;theta&#x27;] - theta_cut) &lt; 0.1]

    # Sort by phi (just in case)
    az_cut.sort(key=lambda d: d[&#x27;phi&#x27;])

    # Extract azimuth (phi) and gain
    phi_deg = [d[&#x27;phi&#x27;] for d in az_cut]
    gain_db = [d[component] for d in az_cut]
    max_gain = np.max(gain_db)

    title = f&#x27;{component} at elevation = {elevation_deg}Â°&#x27;

    if polar:
        phi_rad = np.radians(phi_deg)
        fig, ax = plt.subplots(subplot_kw={&#x27;projection&#x27;: &#x27;polar&#x27;})
        ax.plot(phi_rad, gain_db, label=title)
        ax.set_title(title)
        ax.grid(True)
        ax.set_rmax(max_gain)
        ax.set_rmin(max_gain-40)
        ax.set_rlabel_position(90)
    else:
        fig, ax = plt.subplots()
        ax.plot(phi_deg, gain_db, label=title)
        ax.set_xlabel(&#x27;Azimuth Ï† (degrees)&#x27;)
        ax.set_ylabel(&#x27;Gain (dB)&#x27;)
        ax.set_ylim([max_gain-40,max_gain])
        ax.grid(True)
  
    plt.show()



#==================================================================
# Internal functions
#==================================================================

</pre>
</details>
</details>
<details><summary><span class ='def signature'> def _show_wires(wires, ex_tag, title, color='blue'):</span></summary>
<pre class ='def content'>    import matplotlib.pyplot as plt
    from mpl_toolkits.mplot3d import Axes3D

    print(&quot;Drawing geometry. Please close the geometry window to continue.&quot;)
    fig = plt.figure()
 #   fig.canvas.manager.set_window_title(&#x27;Please close this window to continue&#x27;)
    ax = fig.add_subplot(111, projection=&#x27;3d&#x27;)

    # LOAD highlighting depends on initial tag numbering scheme which needs revision

    for start, end, tag in wires:
        line_color = color
        if (tag == ex_tag):
            line_color = &#x27;red&#x27;
        if (tag &gt;500 and tag &lt; ex_tag): # MAGIC NUMBER
            line_color = &#x27;green&#x27;       
        ax.plot(*zip(start, end), color=line_color if (tag!=ex_tag) else &#x27;red&#x27;)

    plt.draw()  # ensure autoscale limits are calculated

    # Get axis limits
    xlim, ylim, zlim = ax.get_xlim(), ax.get_ylim(), ax.get_zlim()
    mids = [(lim[0] + lim[1]) / 2 for lim in (xlim, ylim, zlim)]
    spans = [lim[1] - lim[0] for lim in (xlim, ylim, zlim)]
    max_range = max(spans)

    # Set equal range around each midpoint
    ax.set_xlim(mids[0] - max_range/2, mids[0] + max_range/2)
    ax.set_ylim(mids[1] - max_range/2, mids[1] + max_range/2)
    ax.set_zlim(mids[2] - max_range/2, mids[2] + max_range/2)

    ax.set_xlabel(&#x27;X&#x27;)
    ax.set_ylabel(&#x27;Y&#x27;)
    ax.set_zlabel(&#x27;Z&#x27;)
    ax.set_title(title)
    
    plt.tight_layout()
    plt.show()


</pre>
</details>
<details><summary><span class ='def signature'> def _plot_gains(pattern_data, azimuth_deg = None, elevation_deg = None):</span></summary>
<pre class ='def content'>    import matplotlib.pyplot as plt
    import numpy as np
        
    # Filter data for fixed elevation (theta)
    if(elevation_deg is not None):
        theta_cut = 90 - elevation_deg
        print(f&quot;Plotting gain for elevation = {elevation_deg} i.e. theta = {theta_cut}&quot;)
        cut = [d for d in pattern_data if abs(d[&#x27;theta&#x27;] - theta_cut) &lt; 0.1]
        angle_deg = [d[&#x27;phi&#x27;] for d in cut]
        title = f&#x27;elevation = {elevation_deg}Â°&#x27;

    # Filter data for fixed azimuth (phi)
    if(azimuth_deg is not None):
        phi_cut = azimuth_deg 
        print(f&quot;Plotting gain for azimuth = {azimuth_deg} i.e. phi = {phi_cut}&quot;)
        cut = [d for d in pattern_data if abs(d[&#x27;phi&#x27;] - phi_cut) &lt; 0.1]
        angle_deg = [d[&#x27;theta&#x27;] for d in cut]
        title = f&#x27;azimuth = {azimuth_deg}Â°&#x27;
 
    fig, ax = plt.subplots(subplot_kw={&#x27;projection&#x27;: &#x27;polar&#x27;})
    angle_rad = np.radians(angle_deg)
    v_gain_db = [d[&#x27;gain_vert_db&#x27;] for d in cut]
    h_gain_db = [d[&#x27;gain_horz_db&#x27;] for d in cut]
    ax.plot(angle_rad, v_gain_db, label=title)
    ax.plot(angle_rad, h_gain_db, label=title)
    ax.set_title(title)
    ax.grid(True)
    
    vmax = max(v_gain_db)
    hmax = max(h_gain_db)

    print(vmax,hmax)
    pmax = max(vmax,hmax)
    
    ax.set_rmax(pmax)
    ax.set_rmin(pmax-40)
    ax.set_rlabel_position(90)

    # Enable interactive mode for non-blocking plotting
    plt.ion()

    # Display the plot window in non-blocking mode
    plt.show(block=False)



import numpy as np
import copy

</pre>
</details>
<details><summary><span class ='def signature'> def _get_complex_component(pat_data, component):</span></summary>
<pre class ='def content'>    m = np.array([d[component + &#x27;_mag&#x27;] for d in pat_data])
    p = np.radians([d[component + &#x27;_phase_deg&#x27;] for d in pat_data])
    Z = m * np.exp(1j * p)
    return Z

</pre>
</details>
<details><summary><span class ='def signature'> def _subtract_patterns(pat1, pat2):</span></summary>
<pre class ='def content'>    Z_theta_1 = _get_complex_component(pat1, &#x27;E_theta&#x27;)
    Z_theta_2 = _get_complex_component(pat2, &#x27;E_theta&#x27;)
    Z_phi_1 = _get_complex_component(pat1, &#x27;E_phi&#x27;)
    Z_phi_2 = _get_complex_component(pat2, &#x27;E_phi&#x27;)

    pat = copy.deepcopy(pat1)
    for i, d in enumerate(pat):
        d[&#x27;E_theta_mag&#x27;] = np.abs(Z_theta_1[i] - Z_theta_2[i])
        d[&#x27;E_phi_mag&#x27;] = np.abs(Z_phi_1[i] - Z_phi_2[i])
        # Note these lines are mathematically incorrect and simply placeholders:
        d[&#x27;gain_vert_db&#x27;] = 20*np.log10(d[&#x27;E_theta_mag&#x27;])
        d[&#x27;gain_horz_db&#x27;] = 20*np.log10(d[&#x27;E_phi_mag&#x27;])


    return pat

    


    

                                            
</pre>
</details>
<br><div class = 'filename'>components.py</div><br><details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>import numpy as np
import math
from necbol.modeller import GeometryObject,_units

#=================================================================================
# Cannonical components
#=================================================================================

</pre>
</details>
<details><summary><span class ='class signature'> class components:</span></summary>
<pre class ='class content'></pre>
<details><summary><span class ='def signature'>ðŸ§¾ def __init__(self, starting_tag_nr = 0):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>        Sets object_counter to starting_tag_nr (tags number identifies an object)
        and loads the _units module class _units()
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        self.object_counter = starting_tag_nr
        self._units = _units()

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def _new_geometry_object(self):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>        increment the object counter and return a GeometryObject with the counter&#x27;s new value
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        self.object_counter += 1
        iTag = self.object_counter
        return iTag, GeometryObject([])

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def copy_of(self, existing_obj):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>        Returns a clone of existing_obj with a new iTag
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        iTag, obj = self._new_geometry_object()
        for w in existing_obj.wires:
            obj._add_wire(iTag, w[&#x27;nS&#x27;], *w[&#x27;a&#x27;], *w[&#x27;b&#x27;], w[&#x27;wr&#x27;])
        return obj
        
</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def wire_Z(self, **dimensions):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>        Create a straight wire aligned along the Z-axis, centered at the origin.

        The wire extends from -length/2 to +length/2 on the Z-axis, with the specified diameter.

        dimensions:
            length_{units_string} (float): Length of the wire. 
            wire_diameter_{units_string} (float): Diameter of the wire.
            In each case, the unit suffix (e.g., _mm, _m) must be present in the units class dictionary &#x27;_UNIT_FACTORS&#x27; (see units.py)
        Returns:
            obj (GeometryObject): The constructed geometry object with the defined wire.
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        iTag, obj = self._new_geometry_object()
        dimensions_m = self._units._from_suffixed_dimensions(dimensions)
        half_length_m = dimensions_m.get(&#x27;length_m&#x27;)/2
        wire_radius_m = dimensions_m.get(&#x27;wire_diameter_m&#x27;)/2
        obj._add_wire(iTag, 0, 0, 0, -half_length_m, 0, 0, half_length_m, wire_radius_m)
        return obj
    
</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def rect_loop_XZ(self, **dimensions):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>        Create a rectangular wire loop in the XZ plane, centered at the origin, with the specified wire diameter.
        The &#x27;side&#x27; wires extend from Z=-length/2 to Z=+length/2 at X = +/- width/2.
        The &#x27;top/bottom&#x27; wires extend from X=-width/2 to X=+width/2 at Z = +/- length/2.
        dimensions:
            length_{units_string} (float): &#x27;Length&#x27; (extension along Z) of the rectangle. 
            width_{units_string} (float): &#x27;Width&#x27; (extension along X) of the rectangle. 
            wire_diameter_{units_string} (float): Diameter of the wires.
            In each case, the unit suffix (e.g., _mm, _m) must be present in the units class dictionary &#x27;_UNIT_FACTORS&#x27; (see units.py)
        Returns:
            obj (GeometryObject): The constructed geometry object with the defined wires.
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        iTag, obj = self._new_geometry_object()
        dimensions_m = self._units._from_suffixed_dimensions(dimensions)
        half_length_m = dimensions_m.get(&#x27;length_m&#x27;)/2
        half_width_m = dimensions_m.get(&#x27;width_m&#x27;)/2
        wire_radius_m = dimensions_m.get(&#x27;wire_diameter_m&#x27;)/2        
        obj._add_wire(iTag, 0, -half_width_m , 0, -half_length_m, -half_width_m , 0, half_length_m, wire_radius_m)
        obj._add_wire(iTag, 0,  half_width_m , 0, -half_length_m,  half_width_m , 0, half_length_m, wire_radius_m)
        obj._add_wire(iTag, 0, -half_width_m , 0, -half_length_m,  half_width_m , 0,-half_length_m, wire_radius_m)
        obj._add_wire(iTag, 0, -half_width_m , 0,  half_length_m,  half_width_m , 0, half_length_m, wire_radius_m)
        return obj

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def connector(self, from_object, from_wire_index, from_alpha_wire, to_object, to_wire_index, to_alpha_wire,  wire_diameter_mm = 1.0):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>        Create a single wire from a specified point on the from_object to a specified point on the to_object.
        The point on an object is specified as {ftom|to}_wire_index AND {ftom|to}_alpha_wire, which specify respectively:
              the i&#x27;th wire in the n wires in the object, and
              the distance along that wire divided by that wire&#x27;s length
        Arguments:
            from_object (GeometryObject), from_wire_index (int, 0 .. n_wires_in_from_object - 1), from_alpha_wire (float, 0 .. 1)
            to_object (GeometryObject), to_wire_index (int, 0 .. n_wires_in_to_object - 1), to_alpha_wire (float, 0 .. 1)
        Returns:
            obj (GeometryObject): The constructed geometry object with the defined wire.
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        iTag, obj = self._new_geometry_object()
        from_point = obj._point_on_object(from_object, from_wire_index, from_alpha_wire)
        to_point = obj._point_on_object(to_object, to_wire_index, to_alpha_wire)
        obj._add_wire(iTag, 0, *from_point, *to_point, wire_diameter_mm/2000) 
        return obj

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def helix(self,  wires_per_turn, sense, **dimensions):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>        Create a single helix with axis = Z axis
        Arguments_
            sense (&quot;LH&quot;|&quot;RH&quot;) - the handedness of the helix          
            wires_per_turn (int) - the number of wires to use to represent the helix, per turn
            dimensions:
                radius_{units} (float) - helix radius 
                length_{units} (float) - helix length along Z 
                pitch_{units} (float)  - helix length along Z per whole turn
                wire_diameter_{units} (float) - diameter of wire making the helix
                In each case above, the units suffix (e.g., _mm, _m) must be present in the units class dictionary &#x27;_UNIT_FACTORS&#x27; (see units.py)
        Returns:
            obj (GeometryObject): The constructed geometry object representing the helix.
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        iTag, obj = self._new_geometry_object()
        dimensions_m = self._units._from_suffixed_dimensions(dimensions)
        radius_m = dimensions_m.get(&#x27;diameter_m&#x27;)/2
        length_m = dimensions_m.get(&#x27;length_m&#x27;)
        pitch_m = dimensions_m.get(&#x27;pitch_m&#x27;)
        wire_radius_m = dimensions_m.get(&#x27;wire_diameter_m&#x27;)/2

        turns = length_m / pitch_m
        n_wires = int(turns * wires_per_turn)
        delta_phi = (2 * math.pi) / wires_per_turn  # angle per segment
        delta_z_m = pitch_m / wires_per_turn 
        phi_sign = 1 if sense.upper() == &quot;RH&quot; else -1

        for i in range(n_wires):
            phi1 = phi_sign * delta_phi * i
            phi2 = phi_sign * delta_phi * (i + 1)
            x1 = radius_m * math.cos(phi1)
            y1 = radius_m * math.sin(phi1)
            z1 = delta_z_m * i
            x2 = radius_m * math.cos(phi2)
            y2 = radius_m * math.sin(phi2)
            z2 = delta_z_m * (i + 1)
            obj._add_wire(iTag, 0, x1, y1, z1, x2, y2, z2, wire_radius_m)

        return obj

</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def flexi_helix(self, sense, wires_per_turn, n_cos,r_cos_params,p_cos_params, **dimensions):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>        Create a helix along the Z axis where radius and pitch vary as scaled sums of cosines:

            r(Z) = r0 * Î£ [RA_i * cos(i * Ï€ * Z / l + RP_i)] for i=0..n-1
            p(Z) = p0 * Î£ [PA_i * cos(i * Ï€ * Z / l + PP_i)] for i=0..n-1

        The geometry is generated by stepping through helical phase (Ï†), and computing local radius and pitch from cosine series 
        as functions of normalized Ï† (mapped to Z via cumulative pitch integration).

        Parameters:
            sense (str): &quot;RH&quot; or &quot;LH&quot; handedness
            wires_per_turn (int): Resolution (segments per full turn)
            n_cos (int): Number of cosine terms
            r_cos_params (list of tuples): [(RA0, RP0), ...] radius amplitudes and phases
            p_cos_params (list of tuples): [(PA0, PP0), ...] pitch amplitudes and phases
            dimensions:
                l_{units} (float): Approximate helix length along Z
                r0_{units} (float): Base radius scale factor
                p0_{units} (float): Base pitch scale factor (length per full turn)
                wire_diameter_{units} (float): Wire thickness

        Returns:
            GeometryObject: The constructed helix geometry object.
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'></pre>
</details>
<details><summary><span class ='def signature'> def _cosine_series(s, terms):</span></summary>
<pre class ='def content'>            return sum(A * math.cos(i * math.pi * s + P) for i, (A, P) in enumerate(terms))

        # === Parameter unpacking and setup ===
        iTag, obj = self._new_geometry_object()
        dimensions_m = self._units._from_suffixed_dimensions(dimensions)

        l_m = dimensions_m.get(&#x27;length_m&#x27;)
        r0_m = dimensions_m.get(&#x27;r0_m&#x27;)
        p0_m = dimensions_m.get(&#x27;p0_m&#x27;)
        wire_radius_m = dimensions_m.get(&#x27;wire_diameter_m&#x27;) / 2

        phi_sign = 1 if sense.upper() == &quot;RH&quot; else -1

        # Estimate number of turns from average pitch and total Z span
        est_turns = l_m / p0_m
        total_phi = est_turns * 2 * math.pi
        n_segments = int(wires_per_turn * est_turns)

        # Precompute all phi values
        phi_list = [i * total_phi / n_segments for i in range(n_segments + 1)]

        # === Generate 3D points ===
        z = -l_m / 2  # center the helix vertically
        points = []

        for i, phi in enumerate(phi_list):
            s = phi / total_phi  # Normalize Ï† to [0, +1]

            radius = r0_m * _cosine_series(s, r_cos_params)
            pitch = p0_m * _cosine_series(s, p_cos_params)
            delta_phi = total_phi / n_segments

            if i &gt; 0:
                z += pitch * delta_phi / (2 * math.pi)
            x = radius * math.cos(phi_sign * phi)
            y = radius * math.sin(phi_sign * phi)
            points.append((x, y, z))

        # === Create wires ===
        for i in range(n_segments):
            x1, y1, z1 = points[i]
            x2, y2, z2 = points[i + 1]
            obj._add_wire(iTag, 0, x1, y1, z1, x2, y2, z2, wire_radius_m)

        return obj


</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def circular_arc(self, n_wires, arc_phi_deg, **dimensions):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>        Create a single circular arc in the XY plane centred on the origin
        Arguments:
            n_wires (int) - the number of wires to use to represent the arc         
            arc_phi_deg (float) - the angle subtended at the origin by the arc in degrees. Note that a continuous circular loop can be constructed by specifying arc_phi_deg = 360.
            dimensions:
                radius_{units} (float) - helix radius 
                wire_diameter_{units} (float) - diameter of wire making the helix
                In each case above, the units suffix (e.g., _mm, _m) must be present in the units class dictionary &#x27;_UNIT_FACTORS&#x27; (see units.py)
        Returns:
            obj (GeometryObject): The constructed geometry object representing the helix.
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        iTag, obj = self._new_geometry_object()
        dimensions_m = self._units._from_suffixed_dimensions(dimensions)
        radius_m = dimensions_m.get(&#x27;diameter_m&#x27;)/2
        wire_radius_m = dimensions_m.get(&#x27;wire_diameter_m&#x27;)/2    

        delta_phi_deg = arc_phi_deg / n_wires        
        for i in range(n_wires):
            ca, sa = obj._cos_sin(delta_phi_deg * i)
            x1 = radius_m * ca
            y1 = radius_m * sa
            ca, sa = obj._cos_sin(delta_phi_deg * (i+1))
            x2 = radius_m * ca
            y2 = radius_m * sa
            obj._add_wire(iTag, 0, x1, y1, 0, x2, y2, 0, wire_radius_m)

        return obj


</pre>
</details>
</details>
<details><summary><span class ='def signature'>ðŸ§¾ def thin_sheet(self, model, sigma, epsillon_r, force_odd = True, close_start = True, close_end = True, close_bottom = True, close_top = True, enforce_exact_pitch = True, **dimensions):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'> docstring</span></summary>
<pre class ='docstring content'>        Creates a grid of wires interconnected at segment level to economically model a flat sheet
        which is normal to the x axis and extends from z=-height/2 to z= height/2, and y = -length/2 to length/2
        Models *either* conductive or dielectric sheet, not both.
        Set epsillon_r to 1.0 for conductive sheet
        Set epsillon_r &gt; 1.0 for dielectric sheet (conductivity value is then not used)

        Arguments:
            model - the object model being built
            sigma - conductivity in mhos/metre
            epsillon_r - relative dielectric constant
            force_odd = true ensures wires cross at y=z=0
            The four &#x27;close_&#x27; parameters determine whether or not the edges are &#x27;sealed&#x27; with a final wire (if True) or
            not (if False) so that the grid can be joined to other grids without wires overlapping:
                close_end = True completes the grid with a final end z wire at y = length/2 
                close_start = True starts the grid with a z wire at y = -length/2 
                close_top = True completes the grid with a y wire at z = height/2 
                close_bottom = True starts the grid with a y wire at z = -height/2 
            enforce_exact_pitch: if True, length and height are adjusted to fit an integer number
            of grid cells of the specified pitch. If False, length and height remain as specified and
            the grid pitch in Y and Z is adjusted to fit the number of grid cells calculated from the
            grid pitch and force_odd value. Behaviour prior to V2.0.3 was enforce_exact_pitch.

        Dimensions are length_, height_, thickness_, grid_pitch_
</pre>
</details>
<details><summary><span class ='body signature'> body</span></summary>
<pre class ='body content'>        print(&quot;NOTE: The thin_sheet model has been tested functionally but not validated quantitavely&quot;)
        iTag, obj = self._new_geometry_object()
        dimensions_m = self._units._from_suffixed_dimensions(dimensions)
        length_m = dimensions_m.get(&#x27;length_m&#x27;)
        height_m = dimensions_m.get(&#x27;height_m&#x27;)
        grid_pitch_m = dimensions_m.get(&#x27;grid_pitch_m&#x27;)
        thickness_m = dimensions_m.get(&#x27;thickness_m&#x27;)
        E = epsillon_r     
        dG = grid_pitch_m

        nY = int(length_m / dG) + 1
        nZ = int(height_m / dG) + 1
        if (force_odd):
            nY += (nY+1) % 2
            nZ += (nZ+1) % 2
        if (enforce_exact_pitch):
            L = (nY-1)*dG
            H = (nZ-1)*dG
            dY = dG
            dZ = dG
        else:
            dY = L/(nY-1)
            dZ = H/(nz-1)
        E0 = 8.854188 * 1e-12
        C_F_per_metre = E0*(E-1) * thickness_m
        wire_radius_m = thickness_m/2

        # Create sheet
        i0 = 0 if close_start else 1
        i1 = nY if close_end else nY-1
        j0 = 0 if close_bottom else 1
        j1 = nZ if close_top else nZ-1
        for i in range(i0, i1):     # make z wires
            x1, y1, z1, x2, y2, z2 = [0, -L/2+i*dY, -H/2, 0, -L/2+i*dY, H/2]
            nSegs = nZ-1
            obj._add_wire(iTag, nSegs, x1, y1, z1, x2, y2, z2, wire_radius_m)

        for j in range(j0, j1):     # make y wires
            x1, y1, z1, x2, y2, z2 = [0, -L/2, -H/2+j*dZ, 0, L/2, -H/2+j*dZ]
            nSegs = nY-1
            obj._add_wire(iTag, nSegs, x1, y1, z1, x2, y2, z2, wire_radius_m)

        # add conductive / capacitive load to the iTag of this object
        # note we aren&#x27;t ineserting a new segment specifically for the load, so there&#x27;s no need to
        # increment model.LOAD_iTag
        if(epsillon_r &gt; 1.0):
            R_Ohms_per_metre = 1e12
        else:
            R_Ohms_per_metre = 1 / sigma
            C_F_per_metre = 0.0
        # NEC LD card specification https://www.nec2.org/part_3/cards/ld.html
        # Modify this to use &#x27;per unit length&#x27; loads (type 2)
        model.LOADS.append({&#x27;iTag&#x27;: iTag, &#x27;type&#x27;: &#x27;series_per_metre&#x27;, &#x27;value&#x27;: (R_Ohms_per_metre, 0, C_F_per_metre), &#x27;alpha&#x27;: None})
                    
        return obj


</pre>
</details>
</details>
</details>

<br><br><span style = 'font-size:0.8em;color:#666;border-top:1px solid #ddd; font-style:italic'>Made with Docu-lite 1.4.0 by Alan Robinson: github.com/G1OJS/docu-lite/</span></body>
