diff --git a/_G1OJS_workspace/Diamond A144S5R.py b/G1OJS_storage/Diamond A144S5R.py
similarity index 100%
rename from _G1OJS_workspace/Diamond A144S5R.py
rename to G1OJS_storage/Diamond A144S5R.py
diff --git a/_G1OJS_workspace/Diamond A144S5R_with_optimiser.py b/G1OJS_storage/Diamond A144S5R_with_optimiser.py
similarity index 100%
rename from _G1OJS_workspace/Diamond A144S5R_with_optimiser.py
rename to G1OJS_storage/Diamond A144S5R_with_optimiser.py
diff --git a/_G1OJS_workspace/G1OJS_contraspiral_with_optimiser.py b/G1OJS_storage/G1OJS_contraspiral_with_optimiser.py
similarity index 100%
rename from _G1OJS_workspace/G1OJS_contraspiral_with_optimiser.py
rename to G1OJS_storage/G1OJS_contraspiral_with_optimiser.py
diff --git a/dev/G1OJS_flexiHelix.py b/G1OJS_storage/G1OJS_flexiHelix.py
similarity index 100%
rename from dev/G1OJS_flexiHelix.py
rename to G1OJS_storage/G1OJS_flexiHelix.py
diff --git a/_G1OJS_workspace/Moxon_with_optimiser.py b/G1OJS_storage/Moxon_with_optimiser.py
similarity index 100%
rename from _G1OJS_workspace/Moxon_with_optimiser.py
rename to G1OJS_storage/Moxon_with_optimiser.py
diff --git a/_G1OJS_workspace/reference/2m antennas/Clutter and interactions/Diamond beam/make inputs.py b/G1OJS_storage/reference/2m antennas/Clutter and interactions/Diamond beam/make inputs.py
similarity index 100%
rename from _G1OJS_workspace/reference/2m antennas/Clutter and interactions/Diamond beam/make inputs.py
rename to G1OJS_storage/reference/2m antennas/Clutter and interactions/Diamond beam/make inputs.py
diff --git a/_G1OJS_workspace/reference/array.py b/G1OJS_storage/reference/array.py
similarity index 100%
rename from _G1OJS_workspace/reference/array.py
rename to G1OJS_storage/reference/array.py
diff --git a/_G1OJS_workspace/reference/chimney generator.py b/G1OJS_storage/reference/chimney generator.py
similarity index 100%
rename from _G1OJS_workspace/reference/chimney generator.py
rename to G1OJS_storage/reference/chimney generator.py
diff --git a/_G1OJS_workspace/reference/flashing generator.py b/G1OJS_storage/reference/flashing generator.py
similarity index 100%
rename from _G1OJS_workspace/reference/flashing generator.py
rename to G1OJS_storage/reference/flashing generator.py
diff --git a/_G1OJS_workspace/yagi_with_optimiser.py b/G1OJS_storage/yagi_with_optimiser.py
similarity index 100%
rename from _G1OJS_workspace/yagi_with_optimiser.py
rename to G1OJS_storage/yagi_with_optimiser.py
diff --git a/dev/Diamond A144S5R.py b/dev/Diamond A144S5R.py
deleted file mode 100644
index d749e3b..0000000
--- a/dev/Diamond A144S5R.py	
+++ /dev/null
@@ -1,86 +0,0 @@
-
-import sys, os
-import math
-sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
-
-from necbol.nec_wrapper import NECModel
-from necbol import geometry_builder
-from necbol import wire_viewer
-
-def build_antenna(model, l0_mm, l1_mm, l2_mm, l3_mm, l4_mm, dy1_mm, dy2_mm, dy3_mm, dy4_mm, driver_d_mm, d_R_mm, d_D1_mm, d_D2_mm, d_D3_mm):
-
-    model.start_geometry()
-    antenna_components = geometry_builder.components()
-
-    ref = antenna_components.wire_Z(length_mm = l0_mm, wire_diameter_mm = d_R_mm)
-    ref.rotate_ZtoX()
-    driv = antenna_components.wire_Z(length_mm = l1_mm, wire_diameter_mm = driver_d_mm)
-    driv.rotate_ZtoX()
-    driv.translate(dx_m = 0, dy_mm = dy1_mm, dz_m = 0)
-    d1 = antenna_components.wire_Z(length_mm = l2_mm, wire_diameter_mm = d_D1_mm)
-    d1.rotate_ZtoX()
-    d1.translate(dx_m = 0, dy_mm = dy1_mm + dy2_mm, dz_m = 0)
-    d2 = antenna_components.wire_Z(length_mm = l2_mm, wire_diameter_mm = d_D2_mm)
-    d2.rotate_ZtoX()
-    d2.translate(dx_m = 0, dy_mm = dy1_mm + dy2_mm + dy3_mm, dz_m = 0)
-    d3 = antenna_components.wire_Z(length_mm = l2_mm, wire_diameter_mm = d_D3_mm)
-    d3.rotate_ZtoX()
-    d3.translate(dx_m = 0, dy_mm = dy1_mm + dy2_mm + dy3_mm + dy4_mm, dz_m = 0)
-
-    
-    model.place_feed(driv, feed_alpha_object = 0.5)
-
-    model.add(ref)
-    model.add(driv)
-    model.add(d1)
-    model.add(d2)
-    model.add(d3)
-
-    return model
-
-def cost_function(model):
-    vcost = model.vswr()
-    g = model.h_gain()
-    gcost = 20-g
-    return ({"cost":0.1*vcost*vcost + gcost*gcost, "info":f"VSWR:{vcost:.2f} Gain:{g:.2f}"})
-
-def optimise():
-    from necbol.optimisers import RandomOptimiser
-    param_init = params
-    best_params, best_info = RandomOptimiser(build_antenna, param_init, cost_function,
-                                             max_iter=1000, bounds = bounds).optimise(model, verbose=False)
-
-model = NECModel(working_dir="..\\nec_wkg",
-                 model_name = "Diamond AS144S5R",
-                 nec_exe_path="C:\\4nec2\\exe\\nec2dxs11k.exe",
-                 verbose=False)
-model.set_wire_conductivity(sigma = 58000000)
-model.set_frequency(MHz = 144.2)
-model.set_gain_point(azimuth = 90, elevation = 3)
-model.set_ground(eps_r = 11, sigma = 0.01, origin_height_m = 8.0)
-
-orig_params = {'l0_mm': 960, 'l1_mm': 1100, 'l2_mm': 920, 'l3_mm': 920, 'l4_mm': 920,
-          'dy1_mm': 375, 'dy2_mm': 90, 'dy3_mm': 190,'dy4_mm': 265,
-          'driver_d_mm':12, 'other_d_mm':5}
-
-params={'l0_mm': 973.43, 'l1_mm': 1181.45, 'l2_mm': 958.36, 'l3_mm': 548.13, 'l4_mm': 649.32,
-        'dy1_mm': 604.41, 'dy2_mm': 118.42, 'dy3_mm': 265.24, 'dy4_mm': 242.16, 'driver_d_mm': 14.46, 'd_R_mm': 4.97, 'd_D1_mm': 4.97, 'd_D2_mm': 4.97, 'd_D3_mm': 4.97}
-
-bounds = {"l0_mm":(950,1200),"l1_mm":(800,1200),"l2_mm":(800,1200),"dy1_mm":(10,1000),"dy2_mm":(10,1000)}
-
-
-# [] INITIAL: VSWR:1.11 Gain:14.71 with {'l0_mm': 973.43, 'l1_mm': 1181.45, 'l2_mm': 958.36, 'l3_mm': 548.13, 'l4_mm': 649.32, 'dy1_mm': 604.41, 'dy2_mm': 118.42, 'dy3_mm': 265.24, 'dy4_mm': 242.16, 'driver_d_mm': 14.46, 'other_d_mm': 4.97}
-# []   FINAL: VSWR:2.32 Gain:15.03 with {'l0_mm': 988.56, 'l1_mm': 1006.14, 'l2_mm': 925.72, 'l3_mm': 583.52, 'l4_mm': 608.38, 'dy1_mm': 539.83, 'dy2_mm': 124.77, 'dy3_mm': 257.88, 'dy4_mm': 248.42, 'driver_d_mm': 15.10, 'other_d_mm': 5.28}
-
-# [] INITIAL: VSWR:1.11 Gain:14.71 with {'l0_mm': 973.43, 'l1_mm': 1181.45, 'l2_mm': 958.36, 'l3_mm': 548.13, 'l4_mm': 649.32, 'dy1_mm': 604.41, 'dy2_mm': 118.42, 'dy3_mm': 265.24, 'dy4_mm': 242.16, 'driver_d_mm': 14.46, 'd_R_mm': 4.97, 'd_D1_mm': 4.97, 'd_D2_mm': 4.97, 'd_D3_mm': 4.97}
-# []   FINAL: VSWR:1.28 Gain:15.04 with {'l0_mm': 988.39, 'l1_mm': 932.91, 'l2_mm': 921.64, 'l3_mm': 543.56, 'l4_mm': 805.03, 'dy1_mm': 563.23, 'dy2_mm': 130.66, 'dy3_mm': 214.39, 'dy4_mm': 244.76, 'driver_d_mm': 17.36, 'd_R_mm': 4.58, 'd_D1_mm': 4.37, 'd_D2_mm': 5.58, 'd_D3_mm': 5.30}
-
-model = build_antenna(model, **params)
-model.write_nec()
-model.run_nec()
-wire_viewer.view_nec_input(model.nec_in, model.EX_TAG, title = model.model_name)
-
-
-print("Done")
-
-
diff --git a/dev/Diamond A144S5R_with_optimiser.py b/dev/Diamond A144S5R_with_optimiser.py
deleted file mode 100644
index c15862a..0000000
--- a/dev/Diamond A144S5R_with_optimiser.py	
+++ /dev/null
@@ -1,86 +0,0 @@
-
-import sys, os
-import math
-sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
-
-from necbol.nec_wrapper import NECModel
-from necbol import geometry_builder
-from necbol import wire_viewer
-
-def build_antenna(model, l0_mm, l1_mm, l2_mm, l3_mm, l4_mm, dy1_mm, dy2_mm, dy3_mm, dy4_mm, driver_d_mm, d_R_mm, d_D1_mm, d_D2_mm, d_D3_mm):
-
-    model.start_geometry()
-    antenna_components = geometry_builder.components()
-
-    ref = antenna_components.wire_Z(length_mm = l0_mm, wire_diameter_mm = d_R_mm)
-    ref.rotate_ZtoX()
-    driv = antenna_components.wire_Z(length_mm = l1_mm, wire_diameter_mm = driver_d_mm)
-    driv.rotate_ZtoX()
-    driv.translate(dx_m = 0, dy_mm = dy1_mm, dz_m = 0)
-    d1 = antenna_components.wire_Z(length_mm = l2_mm, wire_diameter_mm = d_D1_mm)
-    d1.rotate_ZtoX()
-    d1.translate(dx_m = 0, dy_mm = dy1_mm + dy2_mm, dz_m = 0)
-    d2 = antenna_components.wire_Z(length_mm = l2_mm, wire_diameter_mm = d_D2_mm)
-    d2.rotate_ZtoX()
-    d2.translate(dx_m = 0, dy_mm = dy1_mm + dy2_mm + dy3_mm, dz_m = 0)
-    d3 = antenna_components.wire_Z(length_mm = l2_mm, wire_diameter_mm = d_D3_mm)
-    d3.rotate_ZtoX()
-    d3.translate(dx_m = 0, dy_mm = dy1_mm + dy2_mm + dy3_mm + dy4_mm, dz_m = 0)
-
-    
-    model.place_feed(driv, feed_alpha_object = 0.5)
-
-    model.add(ref)
-    model.add(driv)
-    model.add(d1)
-    model.add(d2)
-    model.add(d3)
-
-    return model
-
-def cost_function(model):
-    vcost = model.vswr()
-    g = model.h_gain()
-    gcost = 20-g
-    return ({"cost":0.1*vcost*vcost + gcost*gcost, "info":f"VSWR:{vcost:.2f} Gain:{g:.2f}"})
-
-def optimise():
-    from necbol.optimisers import RandomOptimiser
-    param_init = params
-    best_params, best_info = RandomOptimiser(build_antenna, param_init, cost_function,
-                                             max_iter=1000, bounds = bounds).optimise(model, verbose=False)
-
-model = NECModel(working_dir="..\\nec_wkg",
-                 model_name = "Diamond AS144S5R Optimised",
-                 nec_exe_path="C:\\4nec2\\exe\\nec2dxs11k.exe",
-                 verbose=False)
-model.set_wire_conductivity(sigma = 58000000)
-model.set_frequency(MHz = 144.2)
-model.set_gain_point(azimuth = 90, elevation = 3)
-model.set_ground(eps_r = 11, sigma = 0.01, origin_height_m = 8.0)
-
-orig_params = {'l0_mm': 960, 'l1_mm': 1100, 'l2_mm': 920, 'l3_mm': 920, 'l4_mm': 920,
-          'dy1_mm': 375, 'dy2_mm': 90, 'dy3_mm': 190,'dy4_mm': 265,
-          'driver_d_mm':12, 'other_d_mm':5}
-
-params={'l0_mm': 973.43, 'l1_mm': 1181.45, 'l2_mm': 958.36, 'l3_mm': 548.13, 'l4_mm': 649.32,
-        'dy1_mm': 604.41, 'dy2_mm': 118.42, 'dy3_mm': 265.24, 'dy4_mm': 242.16, 'driver_d_mm': 14.46, 'd_R_mm': 4.97, 'd_D1_mm': 4.97, 'd_D2_mm': 4.97, 'd_D3_mm': 4.97}
-
-bounds = {"l0_mm":(950,1200),"l1_mm":(800,1200),"l2_mm":(800,1200),"dy1_mm":(10,1000),"dy2_mm":(10,1000)}
-
-
-# [] INITIAL: VSWR:1.11 Gain:14.71 with {'l0_mm': 973.43, 'l1_mm': 1181.45, 'l2_mm': 958.36, 'l3_mm': 548.13, 'l4_mm': 649.32, 'dy1_mm': 604.41, 'dy2_mm': 118.42, 'dy3_mm': 265.24, 'dy4_mm': 242.16, 'driver_d_mm': 14.46, 'other_d_mm': 4.97}
-# []   FINAL: VSWR:2.32 Gain:15.03 with {'l0_mm': 988.56, 'l1_mm': 1006.14, 'l2_mm': 925.72, 'l3_mm': 583.52, 'l4_mm': 608.38, 'dy1_mm': 539.83, 'dy2_mm': 124.77, 'dy3_mm': 257.88, 'dy4_mm': 248.42, 'driver_d_mm': 15.10, 'other_d_mm': 5.28}
-
-# [] INITIAL: VSWR:1.11 Gain:14.71 with {'l0_mm': 973.43, 'l1_mm': 1181.45, 'l2_mm': 958.36, 'l3_mm': 548.13, 'l4_mm': 649.32, 'dy1_mm': 604.41, 'dy2_mm': 118.42, 'dy3_mm': 265.24, 'dy4_mm': 242.16, 'driver_d_mm': 14.46, 'd_R_mm': 4.97, 'd_D1_mm': 4.97, 'd_D2_mm': 4.97, 'd_D3_mm': 4.97}
-# []   FINAL: VSWR:1.28 Gain:15.04 with {'l0_mm': 988.39, 'l1_mm': 932.91, 'l2_mm': 921.64, 'l3_mm': 543.56, 'l4_mm': 805.03, 'dy1_mm': 563.23, 'dy2_mm': 130.66, 'dy3_mm': 214.39, 'dy4_mm': 244.76, 'driver_d_mm': 17.36, 'd_R_mm': 4.58, 'd_D1_mm': 4.37, 'd_D2_mm': 5.58, 'd_D3_mm': 5.30}
-
-model = build_antenna(model, **params)
-model.write_nec()
-wire_viewer.view_nec_input(model.nec_in, model.EX_TAG, title = model.model_name)
-optimise()
-
-
-print("Done")
-
-
diff --git a/dev/G1OJS_contraspiral_with_optimiser.py b/dev/G1OJS_contraspiral_with_optimiser.py
deleted file mode 100644
index d0da612..0000000
--- a/dev/G1OJS_contraspiral_with_optimiser.py
+++ /dev/null
@@ -1,89 +0,0 @@
-
-import sys, os
-sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
-
-from necbol.nec_wrapper import NECModel
-from necbol import geometry_builder
-from necbol import wire_viewer
-
-def cost_function(model):
-    vcost = model.vswr()
-    g = model.h_gain()
-    gcost = 15-g
-    return ({"cost":vcost*vcost + gcost*gcost, "info":f"VSWR:{vcost:.2f} Gain:{g:.2f}"})
-
-def build_contraspiral(model, d_mm, l_mm, main_wire_diameter_mm, helix_sep_mm, cld_mm, cl_alpha, cl_spacing_mm):
-
-    model.start_geometry()
-    antenna_components = geometry_builder.components()
-
-    coupling_loop_wire_diameter_mm = 2.0
-    
-    bottom_helix = antenna_components.helix(diameter_mm = d_mm,
-                                     length_mm = l_mm,
-                                     pitch_mm = l_mm / 2,
-                                     sense = "RH",
-                                     wires_per_turn = 36,
-                                     wire_diameter_mm = main_wire_diameter_mm)
-
-    top_helix = antenna_components.helix(diameter_mm = d_mm,
-                                     length_mm = l_mm,
-                                     pitch_mm = l_mm / 2,
-                                     sense = "LH",
-                                     wires_per_turn = 36,
-                                     wire_diameter_mm = main_wire_diameter_mm)
-    top_helix.translate(dx_m = 0, dy_m=0, dz_mm = l_mm + helix_sep_mm)
-
-    link = antenna_components.connector(bottom_helix, 71, 1, top_helix, 0, 0, wire_diameter_mm = main_wire_diameter_mm)
-    
-    coupling_loop = antenna_components.circular_arc(diameter_mm = cld_mm,
-                                                    arc_phi_deg = 360,
-                                                    n_wires=36,
-                                                    wire_diameter_mm = coupling_loop_wire_diameter_mm)
-    
-    model.place_feed(coupling_loop, feed_alpha_object=0)
-#    model.place_series_RLC_load(top_helix, R_ohms = 0, L_uH = 0, C_pf = 50, load_alpha_object=0.5)
-
-    cl_offset_z_mm = cl_alpha*l_mm
-    cl_offset_x_mm = (d_mm - cld_mm - coupling_loop_wire_diameter_mm - main_wire_diameter_mm)/2
-    cl_offset_x_mm -= cl_spacing_mm
-    coupling_loop.translate(dx_mm = cl_offset_x_mm, dy_m = 0, dz_mm = cl_offset_z_mm)
-
-    model.add(bottom_helix)
-    model.add(coupling_loop)
-    model.add(top_helix)
-    model.add(link)
-    
-    return model
-
-
-from necbol.optimisers import RandomOptimiser
-
-model = NECModel(working_dir="..\\nec_wkg",
-                 model_name = "G1OJS Contraspiral",
-                 nec_exe_path="C:\\4nec2\\exe\\nec2dxs11k.exe",
-                 verbose=False)
-model.set_wire_conductivity(sigma = 58000000)
-model.set_frequency(MHz = 144.2)
-model.set_gain_point(azimuth = 90, elevation = 3)
-model.set_ground(eps_r = 11, sigma = 0.01, origin_height_m = 8.0)
-
-param_init = {"d_mm":151, "l_mm":131, "main_wire_diameter_mm":2, "helix_sep_mm":122, "cld_mm":81, "cl_alpha":0.505, "cl_spacing_mm":2.1}
-
-model=build_contraspiral(model, **param_init)
-model.write_nec()
-wire_viewer.view_nec_input(model.nec_in, model.EX_TAG, title = model.model_name)
-
-opt = RandomOptimiser(
-    build_fn = build_contraspiral,
-    param_init = param_init,
-    cost_fn = cost_function,
-)
-
-best_params, best_info = opt.optimise(model, verbose=False)
-
-
-
-print("Done")
-
-
diff --git a/dev/Moxon_with_optimiser.py b/dev/Moxon_with_optimiser.py
deleted file mode 100644
index 65afb96..0000000
--- a/dev/Moxon_with_optimiser.py
+++ /dev/null
@@ -1,86 +0,0 @@
-
-import sys, os
-import math
-sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
-
-from necbol.nec_wrapper import NECModel
-from necbol import geometry_builder
-from necbol import wire_viewer
-
-def build_antenna(model, A_mm, B_mm, C_mm, D_mm, main_wire_diameter_mm):
-
-    E_mm  = B_mm + C_mm + D_mm
-
-    model.start_geometry()
-    antenna_components = geometry_builder.components()
-
-    front = antenna_components.wire_Z(length_mm = A_mm, wire_diameter_mm = main_wire_diameter_mm)
-    front.rotate_ZtoX()
-    front.translate(dx_mm = 0, dy_mm = E_mm , dz_mm = 0)
-
-    front_left = antenna_components.wire_Z(length_mm = B_mm, wire_diameter_mm = main_wire_diameter_mm)
-    front_left.rotate_ZtoX()
-    front_left.rotate_around_Z(90)
-    front_left.translate(dx_mm = -A_mm/2, dy_mm = B_mm/2 + C_mm + D_mm, dz_mm = 0)
-
-    front_right = antenna_components.copy_of(front_left)
-    front_right.translate(dx_mm = A_mm, dy_mm = 0, dz_mm = 0)
-
-    rear = antenna_components.copy_of(front)
-    rear.translate(dx_mm = 0, dy_mm = -E_mm, dz_mm = 0)
-
-    rear_left = antenna_components.wire_Z(length_mm =D_mm, wire_diameter_mm = main_wire_diameter_mm)
-    rear_left.rotate_ZtoX()
-    rear_left.rotate_around_Z(90)
-    rear_left.translate(dx_mm = -A_mm/2, dy_mm = D_mm/2, dz_mm = 0)
-
-    rear_right = antenna_components.copy_of(rear_left)
-    rear_right.translate(dx_mm = A_mm, dy_mm = 0, dz_mm = 0)
- 
-    model.place_feed(front, feed_alpha_object = 0.5)
-
-    model.add(front)
-    model.add(front_left)
-    model.add(front_right)
-    model.add(rear)
-    model.add(rear_left)
-    model.add(rear_right)    
- 
-    return model
-
-def cost_function(model):
-    vcost = model.vswr()
-    g = model.h_gain()
-    gcost = 15-g
-    return ({"cost":vcost*vcost + gcost*gcost, "info":f"VSWR:{vcost:.2f} Gain:{g:.2f}"})
-
-def optimise():
-    from necbol.optimisers import RandomOptimiser
-    param_init = params
-    bounds = {"l0_mm":(800,1200),"l1_mm":(800,1200),"l2_mm":(800,1200),"y1_mm":(100,310),"y2_mm":(320,800)}
-    best_params, best_info = RandomOptimiser(build_antenna, param_init, cost_function,
-                                             max_iter=1000, bounds = bounds).optimise(model, verbose=False)
-
-model = NECModel(working_dir="..\\nec_wkg",
-                 model_name = "Moxon example",
-                 nec_exe_path="C:\\4nec2\\exe\\nec2dxs11k.exe",
-                 verbose=False)
-model.set_wire_conductivity(sigma = 58000000)
-model.set_frequency(MHz = 144.2)
-model.set_gain_point(azimuth = 90, elevation = 3)
-model.set_ground(eps_r = 11, sigma = 0.01, origin_height_m = 8.0)
-
-params = {'A_mm': 750, 'B_mm': 100, 'C_mm': 30, 'D_mm': 140, 'main_wire_diameter_mm': 10}
-# Optimiser Results (copy and paste into your antenna file for reference)
-# [] INITIAL: VSWR:1.60 Gain:11.25 with {'A_mm': '750.00', 'B_mm': '100.00', 'C_mm': '30.00', 'D_mm': '140.00', 'main_wire_diameter_mm': '10.00'}
-# []   FINAL: VSWR:1.57 Gain:12.00 with {'A_mm': '727.87', 'B_mm': '98.98', 'C_mm': '26.05', 'D_mm': '133.48', 'main_wire_diameter_mm': '9.72'}
-
-
-model = build_antenna(model, **params)
-model.write_nec()
-wire_viewer.view_nec_input(model.nec_in, model.EX_TAG, title = model.model_name)
-
-optimise()
-print("Done")
-
-
diff --git a/dev/Yagi_with_optimiser.py b/dev/Yagi_with_optimiser.py
deleted file mode 100644
index 07fbc57..0000000
--- a/dev/Yagi_with_optimiser.py
+++ /dev/null
@@ -1,70 +0,0 @@
-
-import sys, os
-import math
-sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
-
-from necbol.nec_wrapper import NECModel
-from necbol import geometry_builder
-from necbol import wire_viewer
-
-def build_antenna(model, l0_mm, l1_mm, l2_mm, dy1_mm, dy2_mm, w0d_mm, w1d_mm, w2d_mm):
-
-    model.start_geometry()
-    antenna_components = geometry_builder.components()
-
-    ref = antenna_components.wire_Z(length_mm = l0_mm, wire_diameter_mm = w0d_mm)
-    ref.rotate_ZtoX()
-    driv = antenna_components.wire_Z(length_mm = l1_mm, wire_diameter_mm = w1d_mm)
-    driv.rotate_ZtoX()
-    driv.translate(dx_m = 0, dy_mm = dy1_mm, dz_m = 0)
-    d1 = antenna_components.wire_Z(length_mm = l2_mm, wire_diameter_mm = w2d_mm)
-    d1.rotate_ZtoX()
-    d1.translate(dx_m = 0, dy_mm = dy1_mm + dy2_mm, dz_m = 0)
-    
-    model.place_feed(driv, feed_alpha_object = 0.5)
-
-    model.add(ref)
-    model.add(driv)
-    model.add(d1)
-
-    return model
-
-def cost_function(model):
-    vcost = model.vswr()
-    g = model.h_gain()
-    gcost = 15-g
-    return ({"cost":0.1*vcost*vcost + gcost*gcost, "info":f"VSWR:{vcost:.2f} Gain:{g:.2f}"})
-
-def optimise():
-    from necbol.optimisers import RandomOptimiser
-    param_init = params
-    best_params, best_info = RandomOptimiser(build_antenna, param_init, cost_function,
-                                             max_iter=1000, bounds = bounds).optimise(model, verbose=False)
-
-model = NECModel(working_dir="..\\nec_wkg",
-                 model_name = "2m Yagi 3 ele indep wire radii",
-                 nec_exe_path="C:\\4nec2\\exe\\nec2dxs11k.exe",
-                 verbose=False)
-model.set_wire_conductivity(sigma = 58000000)
-model.set_frequency(MHz = 144.2)
-model.set_gain_point(azimuth = 90, elevation = 3)
-model.set_ground(eps_r = 11, sigma = 0.01, origin_height_m = 8.0)
-
-params = {'l0_mm': 708.92, 'l1_mm': 1021.76, 'l2_mm': 939.93, 'dy1_mm': 154.03, 'dy2_mm': 208.08, 'w0d_mm': 8.64, 'w1d_mm': 11.25, 'w2d_mm': 7.85}
-bounds = {"l0_mm":(950,1200),"l1_mm":(800,1200),"l2_mm":(800,1200),"dy1_mm":(10,1000),"dy2_mm":(10,1000)}
-
-# Optimiser Results (copy and paste into your antenna file for reference)
-# [] INITIAL: VSWR:2.31 Gain:12.00 with {'l0_mm': 800.01, 'l1_mm': 1030.42, 'l2_mm': 946.23, 'dy1_mm': 172.44, 'dy2_mm': 189.56, 'w0d_mm': 9.06, 'w1d_mm': 10.97, 'w2d_mm': 7.50}
-# []   FINAL: VSWR:2.11 Gain:12.17 with {'l0_mm': 708.92, 'l1_mm': 1021.76, 'l2_mm': 939.93, 'dy1_mm': 154.03, 'dy2_mm': 208.08, 'w0d_mm': 8.64, 'w1d_mm': 11.25, 'w2d_mm': 7.85}
-# []   FINAL: VSWR:2.08 Gain:12.23 with {'l0_mm': 669.80, 'l1_mm': 1015.67, 'l2_mm': 939.54, 'dy1_mm': 151.21, 'dy2_mm': 216.39, 'w0d_mm': 8.79, 'w1d_mm': 11.54, 'w2d_mm': 7.54}
-
-
-model = build_antenna(model, **params)
-model.write_nec()
-wire_viewer.view_nec_input(model.nec_in, model.EX_TAG, title = model.model_name)
-optimise()
-
-
-print("Done")
-
-
diff --git a/dev/builder_test.py b/dev/builder_test.py
deleted file mode 100644
index 83f4127..0000000
--- a/dev/builder_test.py
+++ /dev/null
@@ -1,30 +0,0 @@
-
-import sys, os
-import math
-sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
-
-from necbol.nec_wrapper import NECModel
-from necbol import geometry_builder
-from necbol import GUI_builder
-
-
-model = NECModel(working_dir="..\\nec_wkg",
-                 model_name = "New",
-                 nec_exe_path="C:\\4nec2\\exe\\nec2dxs11k.exe",
-                 verbose=False)
-model.set_wire_conductivity(sigma = 58000000)
-model.set_frequency(MHz = 144.2)
-model.set_gain_point(azimuth = 90, elevation = 3)
-model.set_ground(eps_r = 11, sigma = 0.01, origin_height_m = 8.0)
-model.start_geometry()
-antenna_components = geometry_builder.components()
-#model.write_nec()
-
-print(model.model_text)
-
-GUI_builder.build(model,  antenna_components, title = model.model_name)
-
-
-print("Done")
-
-
diff --git a/dev/necbol/GUI_builder.py b/dev/necbol/GUI_builder.py
deleted file mode 100644
index b527198..0000000
--- a/dev/necbol/GUI_builder.py
+++ /dev/null
@@ -1,129 +0,0 @@
-"""
-This file is part of the "NECBOL Plain Language Python NEC Runner"
-Copyright (c) 2025 Alan Robinson G1OJS
-
-MIT License
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-"""
-
-import matplotlib.pyplot as plt
-import mpl_toolkits.mplot3d
-
-def parse_model_text(model):
-
-    wires = []
-    for line in model.model_text.splitlines():
-        print(line)
-        if line.startswith("GW"):
-            parts = line.strip().split()
-            if len(parts) >= 9:
-                # NEC input is: GW tag seg x1 y1 z1 x2 y2 z2 radius
-                x1, y1, z1 = map(float, parts[3:6])
-                x2, y2, z2 = map(float, parts[6:9])
-                tag = int(parts[1])
-                wires.append(((x1, y1, z1), (x2, y2, z2), tag))
-    return wires
-
-def add(model, antenna_components):
-    print("add")
-    
-    w = antenna_components.wire_Z(length_mm = 2000, wire_diameter_mm = 1.0)
-    model.add(w)
-
-
-def draw_nec(model):
-    global plt,fig, ax
-
-    print("draw")
-    fig.clear()
-    ax = fig.add_subplot(111, projection='3d')
-    wires = parse_model_text(model)
-    for start, end, tag in wires:
-        print("draw wire")
-        ax.plot(*zip(start, end), color='blue' if (tag!=model.EX_TAG) else 'red')
-    plt.draw()  # ensure autoscale limits are calculated
-    xlim, ylim, zlim = ax.get_xlim(), ax.get_ylim(), ax.get_zlim()
-    mids = [(lim[0] + lim[1]) / 2 for lim in (xlim, ylim, zlim)]
-    spans = [lim[1] - lim[0] for lim in (xlim, ylim, zlim)]
-    max_range = max(spans)
-    ax.set_xlim(mids[0] - max_range/2, mids[0] + max_range/2)
-    ax.set_ylim(mids[1] - max_range/2, mids[1] + max_range/2)
-    ax.set_zlim(mids[2] - max_range/2, mids[2] + max_range/2)
-    ax.set_xlabel('X')
-    ax.set_ylabel('Y')
-    ax.set_zlabel('Z')
-    plt.ion()
-    plt.show()
-    plt.draw()
-
-    return plt
-
-
-def build(model, antenna_components, title):
-    from matplotlib.backend_bases import MouseButton
-    global plt,fig
-    label=""
-    fig = plt.figure(label)
-    plt = draw_nec(model)
-    ends = [None, None]
-
-    
-    def on_move(event):
-
-        pass
-
-    def on_click(event):
-        if event.button is MouseButton.RIGHT:
-            if event.inaxes:
-                s = ax.format_coord(event.xdata, event.ydata)
-                p=get_plane_coords(s)
-                if(p):
-                    if(ends[0]):
-                        ends[1]=p
-                        ax.plot([ends[0][0],ends[1][0]],[ends[0][1],ends[1][1]],[ends[0][2],ends[1][2]])
-                        ends[0] = None
-                    else:
-                        ends[0]=p
-                    print(ends)
-                    
-            #add(model, antenna_components)
-            #plt=draw_nec(model)
-
-    binding_id = plt.connect('motion_notify_event', on_move)
-    plt.connect('button_press_event', on_click)
-        
-def get_plane_coords(s):
-    s=s.split(",")
-    if('elevation' in s[0]):
-        return None
-    xyz=[0,0,0]
-    for valstr in s:
-        if('pane' in valstr):
-            continue
-        ordinate = valstr.split("=")[0].strip()
-        i = ['x','y','z'].index(ordinate)
-        
-        xyz[i]=float(valstr.split("=")[1].replace('−','-'))
-    if(xyz[1]==0):
-        xyz[1]=1
-    return xyz
-
-
-
diff --git a/dev/necbol/__init__.py b/dev/necbol/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/dev/necbol/optimisers.py b/dev/necbol/optimisers.py
deleted file mode 100644
index d5a41f2..0000000
--- a/dev/necbol/optimisers.py
+++ /dev/null
@@ -1,129 +0,0 @@
-"""
-This file is part of the "NECBOL Plain Language Python NEC Runner"
-Copyright (c) 2025 Alan Robinson G1OJS
-
-MIT License
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-"""
-
-
-import random, sys
-
-class RandomOptimiser:
-    def __init__(self, build_fn, param_init, cost_fn,
-                 bounds={}, delta_init=0.2, stall_limit=50, max_iter=250, min_delta=0.001):
-        self.build_fn = build_fn
-        self.param_names = list(param_init.keys())
-        self.x_baseline = param_init.copy()
-        self.bounds = bounds
-        self.cost_fn = cost_fn
-        self.delta_x = delta_init
-        self.min_delta = min_delta
-        self.stall_limit = stall_limit
-        self.max_iter = max_iter
-
-    def format_params(self, params):
-        s="{"
-        for k, v in params.items():
-            s = s + f"'{k}': {v:.2f}, "
-        return s[0:-2]+"}"
-
-    def same_line_print(self,text):
-        sys.stdout.write(f"\r{text}          ")
-        sys.stdout.flush()
-
-    def random_variation(self, x):
-        x_new = x.copy()
-        for name in self.param_names:
-            factor = 1 + random.uniform(-self.delta_x, self.delta_x)
-            val = x[name] * factor
-            x_new[name] = val
-            if(name in self.bounds):
-                minv, maxv = self.bounds[name]
-                x_new[name] = max(min(x_new[name], maxv), minv)
-        return x_new
-
-    def optimise(self, model,  verbose=False, tty=True):
-        best_params = self.x_baseline.copy()
-        best_model = self.build_fn(model, **best_params)
-        best_model.write_nec()
-        best_model.run_nec()
-        result = self.cost_fn(best_model)
-        best_cost = result['cost']
-        best_info = result['info']
-        stall_count = 0
-        print("\nSTARTING optimiser. Press CTRL-C to stop")
-        initial_message = f"[] INITIAL: {best_info} with {self.format_params(best_params)}"
-        print(initial_message)
-
-        try:
-            for i in range(self.max_iter):
-                test_params = self.random_variation(best_params)
-                test_model = self.build_fn(model, **test_params)
-                test_model.write_nec()
-                test_model.run_nec()
-                result = self.cost_fn(test_model)
-                test_cost = result['cost']
-                test_info = result['info']
-
-                if test_cost < best_cost:
-                    best_cost = test_cost
-                    best_params = test_params
-                    best_info = test_info
-                    stall_count = 0
-                    if(not tty):
-                        print("")
-                    self.same_line_print(f"[{i}] IMPROVED: {best_info} with {self.format_params(best_params)}")
-                    print("")
-                else:
-                    stall_count += 1
-                    if(tty):
-                        self.same_line_print(f"[{i}] {test_info}")
-                    else:
-                        sys.stdout.write(".")
-
-                if stall_count >= self.stall_limit:
-                    self.delta_x /= 2
-                    if(self.delta_x < self.min_delta):
-                        if(not tty):
-                            print("")
-                        self.same_line_print(f"[{i}] Delta below minimum")
-                        print("")
-                        break
-                    stall_count = 0
-                    if(not tty):
-                        print("")
-                    self.same_line_print(f"[{i}] STALLED: Reducing delta to {self.delta_x}")
-                    print("")
-
-        except KeyboardInterrupt:
-            print("\nINTERRUPTED by user input")
-            
-        best_model = self.build_fn(model, **best_params)
-        best_model.write_nec()
-        best_model.run_nec()
-        result = self.cost_fn(best_model)
-        final_info = result['info']
-        print("\nFINISHED optimising\n")
-        print("# Optimiser Results (copy and paste into your antenna file for reference). \nNote that you can copy the information between the {} to paste in as your new starting parameters.)")
-        print("# "+ initial_message)
-        print(f"# []   FINAL: {final_info} with {self.format_params(best_params)}")
-        
-        return best_params, final_info
diff --git a/dev/necbol/units.py b/dev/necbol/units.py
deleted file mode 100644
index 350013b..0000000
--- a/dev/necbol/units.py
+++ /dev/null
@@ -1,85 +0,0 @@
-"""
-This file is part of the "NECBOL Plain Language Python NEC Runner"
-Copyright (c) 2025 Alan Robinson G1OJS
-
-MIT License
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-"""
-
-import warnings
-
-class units:
-    
-    _UNIT_FACTORS = {
-        "m": 1.0,
-        "mm": 1000.0,
-        "cm": 100.0,
-        "in": 39.3701,
-        "ft": 3.28084,
-    }
-
-    def __init__(self, default_unit: str = "m"):
-        if default_unit not in self._UNIT_FACTORS:
-            raise ValueError(f"Unsupported unit: {default_unit}")
-        self.default_unit = default_unit
-
-    def from_suffixed_params(self, params: dict, whitelist=[]) -> dict:
-        """Converts suffixed values like 'd_mm' to meters.
-
-        Output keys have '_m' suffix unless they already end with '_m',
-        in which case they are passed through unchanged (assumed meters).
-        """
-        
-        out = {}
-        names_seen = []
-        for key, value in params.items():
-    
-            if not isinstance(value, (int, float)):
-                continue  # skip nested dicts or other structures
-
-            name = key
-            suffix = ""
-            if "_" in name:
-                name, suffix = name.rsplit("_", 1)
-                
-            if(name in names_seen):
-                warnstr = f"Duplicate value of '{name}' seen: ignoring latest ({key} = {value})"
-                warnings.warn(warnstr)
-                continue
-
-            names_seen.append(name)
-
-            if suffix in self._UNIT_FACTORS:
-                # Convert value, output key with '_m' suffix
-                out[name + "_m"] = value / self._UNIT_FACTORS[suffix]
-                continue
-
-            if key in whitelist:
-                continue
-            
-            # fallback: no recognised suffix, assume metres
-            warnings.warn(f"No recognised units specified for {name}: '{suffix}' specified, metres assumed")
-            # output key gets '_m' suffix added
-            out[name + "_m"] = value
-
-        return out
-
-
-
diff --git a/dev/necbol/wire_viewer.py b/dev/necbol/wire_viewer.py
deleted file mode 100644
index ba1a1e1..0000000
--- a/dev/necbol/wire_viewer.py
+++ /dev/null
@@ -1,77 +0,0 @@
-"""
-This file is part of the "NECBOL Plain Language Python NEC Runner"
-Copyright (c) 2025 Alan Robinson G1OJS
-
-MIT License
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-"""
-
-
-def parse_nec_wires(file_path):
-    wires = []
-    with open(file_path, 'r') as f:
-        for line in f:
-            if line.startswith("GW"):
-                parts = line.strip().split()
-                if len(parts) >= 9:
-                    # NEC input is: GW tag seg x1 y1 z1 x2 y2 z2 radius
-                    x1, y1, z1 = map(float, parts[3:6])
-                    x2, y2, z2 = map(float, parts[6:9])
-                    tag = int(parts[1])
-                    wires.append(((x1, y1, z1), (x2, y2, z2), tag))
-    return wires
-
-def view_nec_input(file_path, ex_tag, color='blue', title = "3D Viewer"):
-    wires = parse_nec_wires(file_path)
-    view_wires(wires, ex_tag, title, color=color)
-
-
-def view_wires(wires, ex_tag, title, color='blue'):
-    import matplotlib.pyplot as plt
-    from mpl_toolkits.mplot3d import Axes3D
-
-    print("Drawing geometry. Please close the geometry window to continue.")
-    fig = plt.figure(label = 'Please close this window to continue')
-    ax = fig.add_subplot(111, projection='3d')
-
-    for start, end, tag in wires:
-        ax.plot(*zip(start, end), color=color if (tag!=ex_tag) else 'red')
-
-    plt.draw()  # ensure autoscale limits are calculated
-
-    # Get axis limits
-    xlim, ylim, zlim = ax.get_xlim(), ax.get_ylim(), ax.get_zlim()
-    mids = [(lim[0] + lim[1]) / 2 for lim in (xlim, ylim, zlim)]
-    spans = [lim[1] - lim[0] for lim in (xlim, ylim, zlim)]
-    max_range = max(spans)
-
-    # Set equal range around each midpoint
-    ax.set_xlim(mids[0] - max_range/2, mids[0] + max_range/2)
-    ax.set_ylim(mids[1] - max_range/2, mids[1] + max_range/2)
-    ax.set_zlim(mids[2] - max_range/2, mids[2] + max_range/2)
-
-    ax.set_xlabel('X')
-    ax.set_ylabel('Y')
-    ax.set_zlabel('Z')
-    ax.set_title(title)
-    
-    plt.tight_layout()
-    plt.show()
-
diff --git a/examples/circular_slot_cube_with_optimiser.py b/example_circular_slot_cube_with_optimiser.py
similarity index 87%
rename from examples/circular_slot_cube_with_optimiser.py
rename to example_circular_slot_cube_with_optimiser.py
index 224e0af..5ec788b 100644
--- a/examples/circular_slot_cube_with_optimiser.py
+++ b/example_circular_slot_cube_with_optimiser.py
@@ -1,7 +1,7 @@
 
-from necbol.nec_wrapper import NECModel
-from necbol import geometry_builder
-from necbol import wire_viewer
+from necbol.modeller import NECModel
+from necbol.components import components 
+from necbol.gui import show_wires_from_file
 import math
 
 # note that everything from here down is user code to adapt
@@ -9,32 +9,32 @@ import math
 def build_csc(model, d_mm, h_mm, main_wire_diameter_mm, feed_gap_mm):
 
     model.start_geometry()
-    antenna_components = geometry_builder.components()
+    antenna_components = components()
 
     feed_gap_angle_deg = 360*feed_gap_mm / (math.pi*d_mm)
 
     top_loop = antenna_components.circular_arc(diameter_mm = d_mm, arc_phi_deg = 360-feed_gap_angle_deg, n_wires=36, wire_diameter_mm = main_wire_diameter_mm)
     
     bottom_loop = antenna_components.circular_arc(diameter_mm = d_mm, arc_phi_deg = 360-feed_gap_angle_deg,  n_wires=36, wire_diameter_mm = main_wire_diameter_mm)
     
     top_loop.translate(dx_m = 0, dy_m = 0, dz_mm = h_mm)
     
     slot_wire1 = antenna_components.wire_Z(length_mm = h_mm, wire_diameter_mm = main_wire_diameter_mm)
     slot_wire1.translate(dx_mm = d_mm / 2, dy_m = 0, dz_mm = h_mm /2)
     slot_wire1.connect_ends(top_loop)
     slot_wire1.connect_ends(bottom_loop)
 
     slot_wire2 = antenna_components.wire_Z(length_mm = h_mm, wire_diameter_mm = main_wire_diameter_mm)
     slot_wire2.translate(dx_mm = d_mm/2, dy_m = 0, dz_mm = h_mm /2)  
     slot_wire2.rotate_around_Z(angle_deg = -feed_gap_angle_deg)
     slot_wire2.connect_ends(top_loop, tol = 0.1)
     slot_wire2.connect_ends(bottom_loop, tol = 0.1)
 
     model.place_feed(top_loop, feed_alpha_object = 1)
 
     model.add(top_loop)
     model.add(bottom_loop)
     model.add(slot_wire1)
     model.add(slot_wire2)
 
     return model
@@ -55,10 +55,9 @@ def optimise():
     param_init = params
     best_params, best_info = RandomOptimiser(build_csc, param_init, cost_function).optimise(model, verbose=False)
 
-model = NECModel(working_dir="..\\nec_wkg",
+model = NECModel(working_dir="nec_wkg",
                  model_name="Circular slot cube",
-                 nec_exe_path="C:\\4nec2\\exe\\nec2dxs11k.exe",
-                 verbose=False)
+                 nec_exe_path="C:\\4nec2\\exe\\nec2dxs11k.exe")
 model.set_wire_conductivity(sigma = 58000000)
 model.set_frequency(MHz = 144.2)
 model.set_gain_point(azimuth = 90, elevation = 5)
@@ -67,7 +66,7 @@ model.set_ground(eps_r = 11, sigma = 0.01, origin_height_m = 8.0)
 params = {'d_mm': 200, 'h_mm': 200, 'main_wire_diameter_mm': 5, 'feed_gap_mm': 10}
 model = build_csc(model, **params)
 model.write_nec()
-wire_viewer.view_nec_input(model.nec_in, model.EX_TAG, title = model.model_name)
+show_wires_from_file(model.nec_in, model.EX_TAG, title = model.model_name)
 
 optimise()
 
diff --git a/examples/minimal_example_dipole_with_detailed_comments.py b/example_dipole_with_detailed_comments.py
similarity index 90%
rename from examples/minimal_example_dipole_with_detailed_comments.py
rename to example_dipole_with_detailed_comments.py
index 689b746..a48a254 100644
--- a/examples/minimal_example_dipole_with_detailed_comments.py
+++ b/example_dipole_with_detailed_comments.py
@@ -5,16 +5,15 @@
 """
 
 # These lines import NECBOL 
-from necbol.nec_wrapper import NECModel
-from necbol import geometry_builder
-from necbol import wire_viewer
+from necbol.modeller import NECModel
+from necbol.components import components 
+from necbol.gui import show_wires_from_file
 
 # Start an antenna model called model (it can be called anything acceptable as a Python variable),
 # specifying where the working folder should be made, and where the nec executable is on your system
-model = NECModel(working_dir="..\\nec_wkg",
+model = NECModel(working_dir="nec_wkg",
                  model_name = "Vertical Dipole",
-                 nec_exe_path="C:\\4nec2\\exe\\nec2dxs11k.exe",
-                 verbose=False)
+                 nec_exe_path="C:\\4nec2\\exe\\nec2dxs11k.exe")
 
 # These lines set the basic parameters for the model
 # Wire conductivity. Can be omitted if perfect conductivity is OK to assume
@@ -30,8 +29,8 @@ model.set_gain_point(azimuth = 0, elevation = 3)
 model.set_ground(eps_r = 11, sigma = 0.01, origin_height_m = 8.0) 
 
 # Get a 'copy' of the geometry builder class called antenna_components (again, you can change this name if desired)
-antenna_components = geometry_builder.components()
+antenna_components = components ()
 
 # Tell the nec interface to clear any existing geometries and start a new one
 # This clears only geometry definitions, not the definitions made above
 # It's a mandatory line even if there is no existing geometry to clear because it initilises various things
@@ -70,7 +69,7 @@ print(gains, f"vswr:{vswr:.2f}")
 
 # show the geometry (if desired, you can do this immediately following model.write_nec(),
 # but you'll have to close the geometry window if you want anything to happen afterwards)
-wire_viewer.view_nec_input(model.nec_in, model.EX_TAG, title=model.model_name)
+show_wires_from_file(model.nec_in, model.EX_TAG, title=model.model_name)
 
 print(f"\n\nEnd of example {model.model_name}")
 
diff --git a/examples/hentenna_with_supported_reflector.py b/example_hentenna_with_supported_reflector.py
similarity index 85%
rename from examples/hentenna_with_supported_reflector.py
rename to example_hentenna_with_supported_reflector.py
index 1d699b4..5daf1b3 100644
--- a/examples/hentenna_with_supported_reflector.py
+++ b/example_hentenna_with_supported_reflector.py
@@ -1,49 +1,49 @@
 
-from necbol.nec_wrapper import NECModel
-from necbol import geometry_builder
-from necbol import wire_viewer
+from necbol.modeller import NECModel
+from necbol.components import components 
+from necbol.gui import show_wires_from_file
 
 def build_hentenna_yagi(h_m, w_m, fp_m, refl_sep_m, refl_scale, wd_mm):
 
     model.start_geometry()
-
-    antenna_components = geometry_builder.components()   
+    antenna_components = components()
+    
     feed_rod = antenna_components.wire_Z(length_m = w_m,
                                            wire_diameter_mm = wd_mm)
     feed_rod.rotate_ZtoX()
     feed_rod.translate(dx_m = 0, dy_m = 0, dz_m = fp_m)
     
     hentenna_outer_loop = antenna_components.rect_loop_XZ(length_m = h_m,
                                    width_m = w_m,
                                    wire_diameter_mm = wd_mm)
     hentenna_outer_loop.translate(dx_m = 0, dy_m = 0, dz_m = h_m/2)
 
 
     reflector_loop = antenna_components.rect_loop_XZ(length_m = refl_scale*(h_m-fp_m),
                                    width_m = refl_scale*w_m,
                                    wire_diameter_mm = wd_mm)
     
     feed_rod.connect_ends(hentenna_outer_loop)
     reflector_loop.translate(dx_m = 0, dy_m = -refl_sep_m, dz_m = h_m/2 + fp_m/2)
     
     support_rod = antenna_components.connector(from_object = hentenna_outer_loop, from_wire_index=3, from_alpha_wire=0.5,
                                                to_object = reflector_loop, to_wire_index=3, to_alpha_wire=0.5)
     support_rod.connect_ends(hentenna_outer_loop)
     support_rod.connect_ends(reflector_loop)
 
     model.place_feed(feed_rod, feed_wire_index=0, feed_alpha_wire=0.5)
     
     model.add(feed_rod)
     model.add(reflector_loop)
     model.add(hentenna_outer_loop)
     model.add(support_rod)
 
     return model
 
-model = NECModel(working_dir="..\\nec_wkg",
+model = NECModel(working_dir="nec_wkg",
                  model_name = "Hentenna with reflector rectangle",
-                 nec_exe_path="C:\\4nec2\\exe\\nec2dxs11k.exe",
-                 verbose=False)
+                 nec_exe_path="C:\\4nec2\\exe\\nec2dxs11k.exe")
+
 model.set_wire_conductivity(sigma = 58000000)
 model.set_frequency(MHz = 144.2)
 model.set_gain_point(azimuth = 90, elevation = 5)
@@ -65,7 +65,7 @@ for i in range(-5, 5):
     vswr = model.vswr()
     print(f"parameter {parameter:.3f}", gains, f"vswr:{vswr:.2f}")
 
-wire_viewer.view_nec_input(model.nec_in, model.EX_TAG, title=model.model_name)
+show_wires_from_file(model.nec_in, model.EX_TAG, title=model.model_name)
 
 print(f"\n\nEnd of example {model.model_name}")
 
diff --git a/dev/necbol/geometry_builder.py b/necbol/components.py
similarity index 73%
rename from dev/necbol/geometry_builder.py
rename to necbol/components.py
index 5c226be..1e0be43 100644
--- a/dev/necbol/geometry_builder.py
+++ b/necbol/components.py
@@ -25,8 +25,8 @@ SOFTWARE.
 
 import numpy as np
 import math
-from necbol.units import units
+from necbol.modeller import GeometryObject,units
 
 #=================================================================================
 # Cannonical components
 #=================================================================================
@@ -34,362 +34,280 @@ from necbol.units import units
 class components:
     def __init__(self, starting_tag_nr = 0):
         """Sets object_counter to starting_tag_nr (tags number identifies an object)
         and loads the units module class units()"""
         self.object_counter = starting_tag_nr
         self.units = units()
 
     def new_geometry_object(self):
         """increment the object counter and return a GeometryObject with the counter's new value """
         self.object_counter += 1
         iTag = self.object_counter
         return iTag, GeometryObject([])
 
     def copy_of(self, existing_obj):
         """Returns a clone of existing_obj with a new iTag """
         iTag, obj = self.new_geometry_object()
         for w in existing_obj.wires:
             obj.add_wire(iTag, w['nS'], *w['a'], *w['b'], w['wr'])
         return obj
         
     def wire_Z(self, **params):
         """
         Create a straight wire aligned along the Z-axis, centered at the origin.
 
         The wire extends from -length/2 to +length/2 on the Z-axis, with the specified diameter.
 
         Parameters:
             length_{units_string} (float): Length of the wire. 
             wire_diameter_{units_string} (float): Diameter of the wire.
             In each case, the unit suffix (e.g., _mm, _m) must be present in the units class dictionary '_UNIT_FACTORS' (see units.py)
         Returns:
             obj (GeometryObject): The constructed geometry object with the defined wire.
         """
         iTag, obj = self.new_geometry_object()
         params_m = self.units.from_suffixed_params(params)
         half_length_m = params_m.get('length_m')/2
         wire_radius_m = params_m.get('wire_diameter_m')/2
         obj.add_wire(iTag, 0, 0, 0, -half_length_m, 0, 0, half_length_m, wire_radius_m)
         return obj
     
     def rect_loop_XZ(self, **params):
         """
         Create a rectangular wire loop in the XZ plane, centered at the origin, with the specified wire diameter.
         The 'side' wires extend from Z=-length/2 to Z=+length/2 at X = +/- width/2.
         The 'top/bottom' wires extend from X=-width/2 to X=+width/2 at Z = +/- length/2.
         Parameters:
             length_{units_string} (float): 'Length' (extension along Z) of the rectangle. 
             width_{units_string} (float): 'Width' (extension along X) of the rectangle. 
             wire_diameter_{units_string} (float): Diameter of the wires.
             In each case, the unit suffix (e.g., _mm, _m) must be present in the units class dictionary '_UNIT_FACTORS' (see units.py)
         Returns:
             obj (GeometryObject): The constructed geometry object with the defined wires.
         """
         iTag, obj = self.new_geometry_object()
         params_m = self.units.from_suffixed_params(params)
         half_length_m = params_m.get('length_m')/2
         half_width_m = params_m.get('width_m')/2
         wire_radius_m = params_m.get('wire_diameter_m')/2        
         obj.add_wire(iTag, 0, -half_width_m , 0, -half_length_m, -half_width_m , 0, half_length_m, wire_radius_m)
         obj.add_wire(iTag, 0,  half_width_m , 0, -half_length_m,  half_width_m , 0, half_length_m, wire_radius_m)
         obj.add_wire(iTag, 0, -half_width_m , 0, -half_length_m,  half_width_m , 0,-half_length_m, wire_radius_m)
         obj.add_wire(iTag, 0, -half_width_m , 0,  half_length_m,  half_width_m , 0, half_length_m, wire_radius_m)
         return obj
 
     def connector(self, from_object, from_wire_index, from_alpha_wire, to_object, to_wire_index, to_alpha_wire,  wire_diameter_mm = 1.0):
         """
         Create a single wire from a specified point on the from_object to a specified point on the to_object.
         The point on an object is specified as {ftom|to}_wire_index AND {ftom|to}_alpha_wire, which specify respectively:
               the i'th wire in the n wires in the object, and
               the distance along that wire divided by that wire's length
         Parameters:
             from_object (GeometryObject), from_wire_index (int, 0 .. n_wires_in_from_object - 1), from_alpha_wire (float, 0 .. 1)
             to_object (GeometryObject), to_wire_index (int, 0 .. n_wires_in_to_object - 1), to_alpha_wire (float, 0 .. 1)
         Returns:
             obj (GeometryObject): The constructed geometry object with the defined wire.
         """
         iTag, obj = self.new_geometry_object()
-        from_point = _point_on_object(from_object, from_wire_index, from_alpha_wire)
-        to_point = _point_on_object(to_object, to_wire_index, to_alpha_wire)
+        from_point = obj.point_on_object(from_object, from_wire_index, from_alpha_wire)
+        to_point = obj.point_on_object(to_object, to_wire_index, to_alpha_wire)
         obj.add_wire(iTag, 0, *from_point, *to_point, wire_diameter_mm/2000) 
         return obj
 
     def helix(self, **params):
         """
         Create a single helix with axis = Z axis
         Parameters:
             radius_{units} (float) - helix radius 
             length_{units} (float) - helix length along Z 
             pitch_{units} (float)  - helix length along Z per whole turn
             wire_diameter_{units} (float) - diameter of wire making the helix
             In each case above, the units suffix (e.g., _mm, _m) must be present in the units class dictionary '_UNIT_FACTORS' (see units.py)
             wires_per_turn (int) - the number of wires to use to represent the helix, per turn
             sense ("LH"|"RH") - the handedness of the helix          
         Returns:
             obj (GeometryObject): The constructed geometry object representing the helix.
         """
         iTag, obj = self.new_geometry_object()
         params_m = self.units.from_suffixed_params(params, whitelist=['sense','wires_per_turn'])
         radius_m = params_m.get('diameter_m')/2
         length_m = params_m.get('length_m')
         pitch_m = params_m.get('pitch_m')
         wire_radius_m = params_m.get('wire_diameter_m')/2
         sense = params.get("sense", "RH")
         wires_per_turn = params.get("wires_per_turn", 36)
 
         turns = length_m / pitch_m
         n_wires = int(turns * wires_per_turn)
         delta_phi = (2 * math.pi) / wires_per_turn  # angle per segment
         delta_z_m = pitch_m / wires_per_turn 
         phi_sign = 1 if sense.upper() == "RH" else -1
 
         for i in range(n_wires):
             phi1 = phi_sign * delta_phi * i
             phi2 = phi_sign * delta_phi * (i + 1)
             x1 = radius_m * math.cos(phi1)
             y1 = radius_m * math.sin(phi1)
             z1 = delta_z_m * i
             x2 = radius_m * math.cos(phi2)
             y2 = radius_m * math.sin(phi2)
             z2 = delta_z_m * (i + 1)
             obj.add_wire(iTag, 0, x1, y1, z1, x2, y2, z2, wire_radius_m)
 
         return obj
 
     def flexi_helix(self, **params):
         """
         Create a helix along the Z axis where radius and pitch vary as scaled sums of cosines:
 
             r(Z) = r0 * Σ [RA_i * cos(i * π * Z / l + RP_i)] for i=0..n-1
             p(Z) = p0 * Σ [PA_i * cos(i * π * Z / l + PP_i)] for i=0..n-1
 
         The geometry is generated by stepping through helical phase (φ), and computing local radius and pitch from cosine series 
         as functions of normalized φ (mapped to Z via cumulative pitch integration).
 
         Parameters:
             l_{units} (float): Approximate helix length along Z
             r0_{units} (float): Base radius scale factor
             p0_{units} (float): Base pitch scale factor (length per full turn)
             n_cos (int): Number of cosine terms
             r_cos_params (list of tuples): [(RA0, RP0), ...] radius amplitudes and phases
             p_cos_params (list of tuples): [(PA0, PP0), ...] pitch amplitudes and phases
             wire_diameter_{units} (float): Wire thickness
             wires_per_turn (int): Resolution (segments per full turn)
             sense (str): "RH" or "LH" handedness
 
         Returns:
             GeometryObject: The constructed helix geometry object.
         """
 
         def cosine_series(s, terms):
             return sum(A * math.cos(i * math.pi * s + P) for i, (A, P) in enumerate(terms))
 
         # === Parameter unpacking and setup ===
         iTag, obj = self.new_geometry_object()
         params_m = self.units.from_suffixed_params(params, whitelist=['sense', 'wires_per_turn', 'n_cos','r_cos','p_cos'])
 
         l_m = params_m.get('length_m')
         r0_m = params_m.get('r0_m')
         p0_m = params_m.get('p0_m')
         wire_radius_m = params_m.get('wire_diameter_m') / 2
         sense = params.get("sense", "RH")
         wires_per_turn = params.get("wires_per_turn", 36)
 
         r_cos_params = params.get('r_cos_params')
         p_cos_params = params.get('p_cos_params')
         n_cos = params.get('n_cos')
 
         phi_sign = 1 if sense.upper() == "RH" else -1
 
         # Estimate number of turns from average pitch and total Z span
         est_turns = l_m / p0_m
         total_phi = est_turns * 2 * math.pi
         n_segments = int(wires_per_turn * est_turns)
 
         # Precompute all phi values
         phi_list = [i * total_phi / n_segments for i in range(n_segments + 1)]
 
         # === Generate 3D points ===
         z = -l_m / 2  # center the helix vertically
         points = []
 
         for i, phi in enumerate(phi_list):
             s = phi / total_phi  # Normalize φ to [0, +1]
 
             radius = r0_m * cosine_series(s, r_cos_params)
             pitch = p0_m * cosine_series(s, p_cos_params)
             delta_phi = total_phi / n_segments
 
             if i > 0:
                 z += pitch * delta_phi / (2 * math.pi)
             x = radius * math.cos(phi_sign * phi)
             y = radius * math.sin(phi_sign * phi)
             points.append((x, y, z))
 
         # === Create wires ===
         for i in range(n_segments):
             x1, y1, z1 = points[i]
             x2, y2, z2 = points[i + 1]
             obj.add_wire(iTag, 0, x1, y1, z1, x2, y2, z2, wire_radius_m)
 
         return obj
 
 
     def circular_arc(self, **params):
         """
         Create a single circular arc in the XY plane centred on the origin
         Parameters:
             radius_{units} (float) - helix radius 
             wire_diameter_{units} (float) - diameter of wire making the helix
             In each case above, the units suffix (e.g., _mm, _m) must be present in the units class dictionary '_UNIT_FACTORS' (see units.py)
             arc_phi_deg (float) - the angle subtended at the origin by the arc in degrees. Note that a continuous circular loop can be constructed by specifying arc_phi_deg = 360.
             n_wires (int) - the number of wires to use to represent the arc         
         Returns:
             obj (GeometryObject): The constructed geometry object representing the helix.
         """
         iTag, obj = self.new_geometry_object()
         params_m = self.units.from_suffixed_params(params, whitelist=['n_wires','arc_phi_deg'])
         radius_m = params_m.get('diameter_m')/2
         wire_radius_m = params_m.get('wire_diameter_m')/2    
         arc_phi_deg = params.get("arc_phi_deg")
         n_wires = params.get("n_wires", 36)
 
         delta_phi_deg = arc_phi_deg / n_wires        
         for i in range(n_wires):
-            ca, sa = _cos_sin(delta_phi_deg * i)
+            ca, sa = obj.cos_sin(delta_phi_deg * i)
             x1 = radius_m * ca
             y1 = radius_m * sa
-            ca, sa = _cos_sin(delta_phi_deg * (i+1))
+            ca, sa = obj.cos_sin(delta_phi_deg * (i+1))
             x2 = radius_m * ca
             y2 = radius_m * sa
             obj.add_wire(iTag, 0, x1, y1, 0, x2, y2, 0, wire_radius_m)
 
         return obj
 
-#=================================================================================
-# The geometry object that holds a single component plus its methods
-#=================================================================================
-
-class GeometryObject:
-    def __init__(self, wires):
-        self.wires = wires  # list of wire dicts with iTag, nS, x1, y1, ...
-        self.units = units()
-
-    def add_wire(self, iTag, nS, x1, y1, z1, x2, y2, z2, wr):
-        self.wires.append({"iTag":iTag, "nS":nS, "a":(x1, y1, z1), "b":(x2, y2, z2), "wr":wr})
-
-    def get_wires(self):
-        return self.wires
-
-    def translate(self, **params):
-        params_m = self.units.from_suffixed_params(params)
-        for w in self.wires:
-            w['a'] = tuple(map(float,np.array(w['a']) + np.array([params_m.get('dx_m'), params_m.get('dy_m'), params_m.get('dz_m')])))
-            w['b'] = tuple(map(float,np.array(w['b']) + np.array([params_m.get('dx_m'), params_m.get('dy_m'), params_m.get('dz_m')])))
-
-    def rotate_ZtoY(self):
-        R = np.array([[1, 0, 0],[0,  0, 1],[0,  -1, 0]])
-        return self.rotate(R)
-    
-    def rotate_ZtoX(self):
-        R = np.array([[0, 0, 1],[0,  1, 0],[-1,  0, 0]])
-        return self.rotate(R)
-
-    def rotate_around_Z(self, angle_deg):
-        ca, sa = _cos_sin(angle_deg)
-        R = np.array([[ca, -sa, 0],
-                      [sa, ca, 0],
-                      [0, 0, 1]])
-        return self.rotate(R)
-
-    def rotate_around_X(self, angle_deg):
-        ca, sa = _cos_sin(angle_deg)
-        R = np.array([[1, 0, 0],
-                      [0, ca, -sa],
-                      [0, sa, ca]])
-        return self.rotate(R)
-
-    def rotate_around_Y(self, angle_deg):
-        ca, sa = _cos_sin(angle_deg)
-        R = np.array([[ca, 0, sa],
-                      [0, 1, 0],
-                      [-sa, 0, ca]])
-        return self.rotate(R)
-
-    
-    def rotate(self, R):
-        for w in self.wires:
-            a = np.array(w['a'])
-            b = np.array(w['b'])
-            w['a'] = tuple(map(float, R @ a))
-            w['b'] = tuple(map(float, R @ b))
-
-    def connect_ends(self, other, tol=1e-3):
-        wires_to_add=[]
-        for ws in self.wires:
-            for es in [ws["a"], ws["b"]]:
-                for wo in other.wires:
-                    if (_point_should_connect_to_wire(es,wo['a'],wo['b'],tol)):
-                        b = wo["b"]
-                        wo['b']=tuple(es)
-                        wires_to_add.append( (wo['iTag'], 0, *es, *b, wo['wr']) )
-                        break #(for efficiency only)
-        for params in wires_to_add:
-            other.add_wire(*params)
-               
-
-#=================
-# helper functions
-#=================
-
-def _cos_sin(angle_deg):
-    angle_rad = math.pi*angle_deg/180
-    ca = math.cos(angle_rad)
-    sa = math.sin(angle_rad)
-    return ca, sa
-
-def _point_should_connect_to_wire(P, A, B, tol=1e-6):
-    P = np.array(P, dtype=float)
-    A = np.array(A, dtype=float)
-    B = np.array(B, dtype=float)
-    AB = B - A
-    AP = P - A
-    AB_len = np.linalg.norm(AB)
-    # can't connect to a zero length wire using the splitting method
-    # but maybe should allow connecting by having the same co-ordinates
-    if AB_len == 0:
-        return False
-    
-    # Check perpendicular distance from wire axis
-    # if we aren't close enough to the wire axis to need to connect, return false
-    # NOTE: need to align tol with nec's check of volumes intersecting
-    perp_dist = np.linalg.norm(np.cross(AP, AB)) / AB_len
-    if perp_dist > tol: 
-        return False    
-
-    # We *are* close enough to the wire axis but if we're not between the ends, return false
-    t = np.dot(AP, AB) / (AB_len ** 2)
-    if (t<0 or t>1):
-        return False
-    
-    # if we are within 1mm of either end (wires are written to 3dp in m), return false
-    if ((np.linalg.norm(AP) < 0.001) or (np.linalg.norm(B-P) < 0.001)):
-        return False
-
-    return True
-
-
-def _point_on_object(geom_object, wire_index, alpha_wire):
-    if(wire_index> len(geom_object.wires)):
-        wire_index = len(geom_object.wires)
-        alpha_wire = 1.0
-    w = geom_object.wires[wire_index]
-    A = np.array(w["a"], dtype=float)
-    B = np.array(w["b"], dtype=float)
-    P = A + alpha_wire * (B-A)
-    return P
-
-
-
 
+        def thin_sheet(self, model, conductivity_mhos_per_m, epsillon_r, **params):
+            # params model, conductivity_mhos_per_m, epsillon_r, length_, height_, thickness_, grid_pitch_
+            # models *either* conductive or dielectric sheet, not both (add error trap)
+            # Follows method used in https://lso.fe.uni-lj.si/literatura/Razno/SRK2020/SRK2020.10/NEC2/Dielectric_films_NEC2.pdf
+            iTag, obj = self.new_geometry_object()
+            params_m = self.units.from_suffixed_params(params)
+            length_m = params_m.get('length_m')
+            height_m = params_m.get('height_m')
+            grid_pitch_m = params_m.get('grid_pitch_m')
+            thickness_m = params_m.get('thickness_m')
+            E = epsillon_r     
+            dG = grid_pitch_m
+
+            nY = int(length_m / dG) + 1
+            nZ = int(height_m / dG) + 1
+            L = (nY-1)*dG
+            H = (nZ-1)*dG
+            E0 = 8.854188 * 1e-12
+            CD = E0*(E-1) * thickness_m
+            wire_radius_m = thickness_m/2
+
+            # Create sheet
+            for i in range(1, nY-1):
+                x1, y1, z1, x2, y2, z2 = [0, -D/2+i*dG, 0, 0, -D/2+i*dG, H]
+                nSegs = nZ-1
+                obj.add_wire(iTag, 0, x1, y1, z1, x2, y2, z2, wire_radius_m)
+            for i in range(nZ):
+                x1, y1, z1, x2, y2, z2 = [0, -D/2, i*dG, 0, D/2, i*dG]
+                nSegs = nY-1
+                obj.add_wire(iTag, 0, x1, y1, z1, x2, y2, z2, wire_radius_m)
+
+            # add conductive / capacitive load to the iTag of this object
+            # note we aren't ineserting a new segment specifically for the load, so there's no need to
+            # increment model.LOAD_iTag
+            if(epsillon_r > 1.0):
+                R_Ohms = 1e12
+                C_F = CD
+            else:
+                R_Ohms = dG / conductivity_mhos_per_m
+                C_F = 0.0
+            model.LOADS.append(f"LD 1 {self.LOAD_iTag} 0 0 {R_ohms} {1e12} {CD}\n")
+                    
+        return obj
 
 
diff --git a/necbol/geometry_builder.py b/necbol/geometry_builder.py
deleted file mode 100644
index 90873b2..0000000
--- a/necbol/geometry_builder.py
+++ /dev/null
@@ -1,316 +0,0 @@
-"""
-This file is part of the "NECBOL Plain Language Python NEC Runner"
-Copyright (c) 2025 Alan Robinson G1OJS
-
-MIT License
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-"""
-
-import numpy as np
-import math
-from necbol.units import units
-
-#=================================================================================
-# Cannonical components
-#=================================================================================
-
-class components:
-    def __init__(self, starting_tag_nr = 0):
-        """Sets object_counter to starting_tag_nr (tags number identifies an object)
-        and loads the units module class units()"""
-        self.object_counter = starting_tag_nr
-        self.units = units()
-
-    def new_geometry_object(self):
-        """increment the object counter and return a GeometryObject with the counter's new value """
-        self.object_counter += 1
-        iTag = self.object_counter
-        return iTag, GeometryObject([])
-
-    def copy_of(self, existing_obj):
-        """Returns a clone of existing_obj with a new iTag """
-        iTag, obj = self.new_geometry_object()
-        for w in existing_obj.wires:
-            obj.add_wire(iTag, w['nS'], *w['a'], *w['b'], w['wr'])
-        return obj
-        
-    def wire_Z(self, **params):
-        """
-        Create a straight wire aligned along the Z-axis, centered at the origin.
-
-        The wire extends from -length/2 to +length/2 on the Z-axis, with the specified diameter.
-
-        Parameters:
-            length_{units_string} (float): Length of the wire. 
-            wire_diameter_{units_string} (float): Diameter of the wire.
-            In each case, the unit suffix (e.g., _mm, _m) must be present in the units class dictionary '_UNIT_FACTORS' (see units.py)
-        Returns:
-            obj (GeometryObject): The constructed geometry object with the defined wire.
-        """
-        iTag, obj = self.new_geometry_object()
-        params_m = self.units.from_suffixed_params(params)
-        half_length_m = params_m.get('length_m')/2
-        wire_radius_m = params_m.get('wire_diameter_m')/2
-        obj.add_wire(iTag, 0, 0, 0, -half_length_m, 0, 0, half_length_m, wire_radius_m)
-        return obj
-    
-    def rect_loop_XZ(self, **params):
-        """
-        Create a rectangular wire loop in the XZ plane, centered at the origin, with the specified wire diameter.
-        The 'side' wires extend from Z=-length/2 to Z=+length/2 at X = +/- width/2.
-        The 'top/bottom' wires extend from X=-width/2 to X=+width/2 at Z = +/- length/2.
-        Parameters:
-            length_{units_string} (float): 'Length' (extension along Z) of the rectangle. 
-            width_{units_string} (float): 'Width' (extension along X) of the rectangle. 
-            wire_diameter_{units_string} (float): Diameter of the wires.
-            In each case, the unit suffix (e.g., _mm, _m) must be present in the units class dictionary '_UNIT_FACTORS' (see units.py)
-        Returns:
-            obj (GeometryObject): The constructed geometry object with the defined wires.
-        """
-        iTag, obj = self.new_geometry_object()
-        params_m = self.units.from_suffixed_params(params)
-        half_length_m = params_m.get('length_m')/2
-        half_width_m = params_m.get('width_m')/2
-        wire_radius_m = params_m.get('wire_diameter_m')/2        
-        obj.add_wire(iTag, 0, -half_width_m , 0, -half_length_m, -half_width_m , 0, half_length_m, wire_radius_m)
-        obj.add_wire(iTag, 0,  half_width_m , 0, -half_length_m,  half_width_m , 0, half_length_m, wire_radius_m)
-        obj.add_wire(iTag, 0, -half_width_m , 0, -half_length_m,  half_width_m , 0,-half_length_m, wire_radius_m)
-        obj.add_wire(iTag, 0, -half_width_m , 0,  half_length_m,  half_width_m , 0, half_length_m, wire_radius_m)
-        return obj
-
-    def connector(self, from_object, from_wire_index, from_alpha_wire, to_object, to_wire_index, to_alpha_wire,  wire_diameter_mm = 1.0):
-        """
-        Create a single wire from a specified point on the from_object to a specified point on the to_object.
-        The point on an object is specified as {ftom|to}_wire_index AND {ftom|to}_alpha_wire, which specify respectively:
-              the i'th wire in the n wires in the object, and
-              the distance along that wire divided by that wire's length
-        Parameters:
-            from_object (GeometryObject), from_wire_index (int, 0 .. n_wires_in_from_object - 1), from_alpha_wire (float, 0 .. 1)
-            to_object (GeometryObject), to_wire_index (int, 0 .. n_wires_in_to_object - 1), to_alpha_wire (float, 0 .. 1)
-        Returns:
-            obj (GeometryObject): The constructed geometry object with the defined wire.
-        """
-        iTag, obj = self.new_geometry_object()
-        from_point = _point_on_object(from_object, from_wire_index, from_alpha_wire)
-        to_point = _point_on_object(to_object, to_wire_index, to_alpha_wire)
-        obj.add_wire(iTag, 0, *from_point, *to_point, wire_diameter_mm/2000) 
-        return obj
-
-    def helix(self, **params):
-        """
-        Create a single helix with axis = Z axis
-        Parameters:
-            radius_{units} (float) - helix radius 
-            length_{units} (float) - helix length along Z 
-            pitch_{units} (float)  - helix length along Z per whole turn
-            wire_diameter_{units} (float) - diameter of wire making the helix
-            In each case above, the units suffix (e.g., _mm, _m) must be present in the units class dictionary '_UNIT_FACTORS' (see units.py)
-            wires_per_turn (int) - the number of wires to use to represent the helix, per turn
-            sense ("LH"|"RH") - the handedness of the helix          
-        Returns:
-            obj (GeometryObject): The constructed geometry object representing the helix.
-        """
-        iTag, obj = self.new_geometry_object()
-        params_m = self.units.from_suffixed_params(params, whitelist=['sense','wires_per_turn'])
-        radius_m = params_m.get('diameter_m')/2
-        length_m = params_m.get('length_m')
-        pitch_m = params_m.get('pitch_m')
-        wire_radius_m = params_m.get('wire_diameter_m')/2
-        sense = params.get("sense", "RH")
-        wires_per_turn = params.get("wires_per_turn", 36)
-
-        turns = length_m / pitch_m
-        n_wires = int(turns * wires_per_turn)
-        delta_phi = (2 * math.pi) / wires_per_turn  # angle per segment
-        delta_z_m = pitch_m / wires_per_turn 
-        phi_sign = 1 if sense.upper() == "RH" else -1
-
-        for i in range(n_wires):
-            phi1 = phi_sign * delta_phi * i
-            phi2 = phi_sign * delta_phi * (i + 1)
-            x1 = radius_m * math.cos(phi1)
-            y1 = radius_m * math.sin(phi1)
-            z1 = delta_z_m * i
-            x2 = radius_m * math.cos(phi2)
-            y2 = radius_m * math.sin(phi2)
-            z2 = delta_z_m * (i + 1)
-            obj.add_wire(iTag, 0, x1, y1, z1, x2, y2, z2, wire_radius_m)
-
-        return obj
-
-    def circular_arc(self, **params):
-        """
-        Create a single circular arc in the XY plane centred on the origin
-        Parameters:
-            radius_{units} (float) - helix radius 
-            wire_diameter_{units} (float) - diameter of wire making the helix
-            In each case above, the units suffix (e.g., _mm, _m) must be present in the units class dictionary '_UNIT_FACTORS' (see units.py)
-            arc_phi_deg (float) - the angle subtended at the origin by the arc in degrees. Note that a continuous circular loop can be constructed by specifying arc_phi_deg = 360.
-            n_wires (int) - the number of wires to use to represent the arc         
-        Returns:
-            obj (GeometryObject): The constructed geometry object representing the helix.
-        """
-        iTag, obj = self.new_geometry_object()
-        params_m = self.units.from_suffixed_params(params, whitelist=['n_wires','arc_phi_deg'])
-        radius_m = params_m.get('diameter_m')/2
-        wire_radius_m = params_m.get('wire_diameter_m')/2    
-        arc_phi_deg = params.get("arc_phi_deg")
-        n_wires = params.get("n_wires", 36)
-
-        delta_phi_deg = arc_phi_deg / n_wires        
-        for i in range(n_wires):
-            ca, sa = _cos_sin(delta_phi_deg * i)
-            x1 = radius_m * ca
-            y1 = radius_m * sa
-            ca, sa = _cos_sin(delta_phi_deg * (i+1))
-            x2 = radius_m * ca
-            y2 = radius_m * sa
-            obj.add_wire(iTag, 0, x1, y1, 0, x2, y2, 0, wire_radius_m)
-
-        return obj
-
-#=================================================================================
-# The geometry object that holds a single component plus its methods
-#=================================================================================
-
-class GeometryObject:
-    def __init__(self, wires):
-        self.wires = wires  # list of wire dicts with iTag, nS, x1, y1, ...
-        self.units = units()
-
-    def add_wire(self, iTag, nS, x1, y1, z1, x2, y2, z2, wr):
-        self.wires.append({"iTag":iTag, "nS":nS, "a":(x1, y1, z1), "b":(x2, y2, z2), "wr":wr})
-
-    def get_wires(self):
-        return self.wires
-
-    def translate(self, **params):
-        params_m = self.units.from_suffixed_params(params)
-        for w in self.wires:
-            w['a'] = tuple(map(float,np.array(w['a']) + np.array([params_m.get('dx_m'), params_m.get('dy_m'), params_m.get('dz_m')])))
-            w['b'] = tuple(map(float,np.array(w['b']) + np.array([params_m.get('dx_m'), params_m.get('dy_m'), params_m.get('dz_m')])))
-
-    def rotate_ZtoY(self):
-        R = np.array([[1, 0, 0],[0,  0, 1],[0,  -1, 0]])
-        return self.rotate(R)
-    
-    def rotate_ZtoX(self):
-        R = np.array([[0, 0, 1],[0,  1, 0],[-1,  0, 0]])
-        return self.rotate(R)
-
-    def rotate_around_Z(self, angle_deg):
-        ca, sa = _cos_sin(angle_deg)
-        R = np.array([[ca, -sa, 0],
-                      [sa, ca, 0],
-                      [0, 0, 1]])
-        return self.rotate(R)
-
-    def rotate_around_X(self, angle_deg):
-        ca, sa = _cos_sin(angle_deg)
-        R = np.array([[1, 0, 0],
-                      [0, ca, -sa],
-                      [0, sa, ca]])
-        return self.rotate(R)
-
-    def rotate_around_Y(self, angle_deg):
-        ca, sa = _cos_sin(angle_deg)
-        R = np.array([[ca, 0, sa],
-                      [0, 1, 0],
-                      [-sa, 0, ca]])
-        return self.rotate(R)
-
-    
-    def rotate(self, R):
-        for w in self.wires:
-            a = np.array(w['a'])
-            b = np.array(w['b'])
-            w['a'] = tuple(map(float, R @ a))
-            w['b'] = tuple(map(float, R @ b))
-
-    def connect_ends(self, other, tol=1e-3):
-        wires_to_add=[]
-        for ws in self.wires:
-            for es in [ws["a"], ws["b"]]:
-                for wo in other.wires:
-                    if (_point_should_connect_to_wire(es,wo['a'],wo['b'],tol)):
-                        b = wo["b"]
-                        wo['b']=tuple(es)
-                        wires_to_add.append( (wo['iTag'], 0, *es, *b, wo['wr']) )
-                        break #(for efficiency only)
-        for params in wires_to_add:
-            other.add_wire(*params)
-               
-
-#=================
-# helper functions
-#=================
-
-def _cos_sin(angle_deg):
-    angle_rad = math.pi*angle_deg/180
-    ca = math.cos(angle_rad)
-    sa = math.sin(angle_rad)
-    return ca, sa
-
-def _point_should_connect_to_wire(P, A, B, tol=1e-6):
-    P = np.array(P, dtype=float)
-    A = np.array(A, dtype=float)
-    B = np.array(B, dtype=float)
-    AB = B - A
-    AP = P - A
-    AB_len = np.linalg.norm(AB)
-    # can't connect to a zero length wire using the splitting method
-    # but maybe should allow connecting by having the same co-ordinates
-    if AB_len == 0:
-        return False
-    
-    # Check perpendicular distance from wire axis
-    # if we aren't close enough to the wire axis to need to connect, return false
-    # NOTE: need to align tol with nec's check of volumes intersecting
-    perp_dist = np.linalg.norm(np.cross(AP, AB)) / AB_len
-    if perp_dist > tol: 
-        return False    
-
-    # We *are* close enough to the wire axis but if we're not between the ends, return false
-    t = np.dot(AP, AB) / (AB_len ** 2)
-    if (t<0 or t>1):
-        return False
-    
-    # if we are within 1mm of either end (wires are written to 3dp in m), return false
-    if ((np.linalg.norm(AP) < 0.001) or (np.linalg.norm(B-P) < 0.001)):
-        return False
-
-    return True
-
-
-def _point_on_object(geom_object, wire_index, alpha_wire):
-    if(wire_index> len(geom_object.wires)):
-        wire_index = len(geom_object.wires)
-        alpha_wire = 1.0
-    w = geom_object.wires[wire_index]
-    A = np.array(w["a"], dtype=float)
-    B = np.array(w["b"], dtype=float)
-    P = A + alpha_wire * (B-A)
-    return P
-
-
-
-
-
-
diff --git a/necbol/wire_viewer.py b/necbol/gui.py
similarity index 90%
rename from necbol/wire_viewer.py
rename to necbol/gui.py
index ba1a1e1..689b1cf 100644
--- a/necbol/wire_viewer.py
+++ b/necbol/gui.py
@@ -23,55 +23,49 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 """
 
-
-def parse_nec_wires(file_path):
-    wires = []
-    with open(file_path, 'r') as f:
-        for line in f:
-            if line.startswith("GW"):
-                parts = line.strip().split()
-                if len(parts) >= 9:
-                    # NEC input is: GW tag seg x1 y1 z1 x2 y2 z2 radius
-                    x1, y1, z1 = map(float, parts[3:6])
-                    x2, y2, z2 = map(float, parts[6:9])
-                    tag = int(parts[1])
-                    wires.append(((x1, y1, z1), (x2, y2, z2), tag))
-    return wires
-
-def view_nec_input(file_path, ex_tag, color='blue', title = "3D Viewer"):
-    wires = parse_nec_wires(file_path)
-    view_wires(wires, ex_tag, title, color=color)
-
-
-def view_wires(wires, ex_tag, title, color='blue'):
+def show_wires(wires, ex_tag, title, color='blue'):
     import matplotlib.pyplot as plt
     from mpl_toolkits.mplot3d import Axes3D
 
     print("Drawing geometry. Please close the geometry window to continue.")
     fig = plt.figure(label = 'Please close this window to continue')
     ax = fig.add_subplot(111, projection='3d')
 
     for start, end, tag in wires:
         ax.plot(*zip(start, end), color=color if (tag!=ex_tag) else 'red')
 
     plt.draw()  # ensure autoscale limits are calculated
 
     # Get axis limits
     xlim, ylim, zlim = ax.get_xlim(), ax.get_ylim(), ax.get_zlim()
     mids = [(lim[0] + lim[1]) / 2 for lim in (xlim, ylim, zlim)]
     spans = [lim[1] - lim[0] for lim in (xlim, ylim, zlim)]
     max_range = max(spans)
 
     # Set equal range around each midpoint
     ax.set_xlim(mids[0] - max_range/2, mids[0] + max_range/2)
     ax.set_ylim(mids[1] - max_range/2, mids[1] + max_range/2)
     ax.set_zlim(mids[2] - max_range/2, mids[2] + max_range/2)
 
     ax.set_xlabel('X')
     ax.set_ylabel('Y')
     ax.set_zlabel('Z')
     ax.set_title(title)
     
     plt.tight_layout()
     plt.show()
+    
 
+def show_wires_from_file(file_path, ex_tag, color='blue', title = "3D Viewer"):
+    wires = []
+    with open(file_path, 'r') as f:
+        for line in f:
+            if line.startswith("GW"):
+                parts = line.strip().split()
+                if len(parts) >= 9:
+                    # NEC input is: GW tag seg x1 y1 z1 x2 y2 z2 radius
+                    x1, y1, z1 = map(float, parts[3:6])
+                    x2, y2, z2 = map(float, parts[6:9])
+                    tag = int(parts[1])
+                    wires.append(((x1, y1, z1), (x2, y2, z2), tag))
+    show_wires(wires, ex_tag, title, color=color)
diff --git a/dev/necbol/nec_wrapper.py b/necbol/modeller.py
similarity index 63%
rename from dev/necbol/nec_wrapper.py
rename to necbol/modeller.py
index f98afc1..2c9b12a 100644
--- a/dev/necbol/nec_wrapper.py
+++ b/necbol/modeller.py
@@ -23,242 +23,428 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 """
 
+import numpy as np
+import math
+import warnings
 import subprocess
 import os
-import numpy as np
-from necbol.units import units
+
+#=================================================================================
+# The geometry object that holds a single component plus its methods
+#=================================================================================
+
+class GeometryObject:
+    def __init__(self, wires):
+        self.wires = wires  # list of wire dicts with iTag, nS, x1, y1, ...
+        self.units = units()
+
+    def add_wire(self, iTag, nS, x1, y1, z1, x2, y2, z2, wr):
+        self.wires.append({"iTag":iTag, "nS":nS, "a":(x1, y1, z1), "b":(x2, y2, z2), "wr":wr})
+
+    def get_wires(self):
+        return self.wires
+
+    def translate(self, **params):
+        params_m = self.units.from_suffixed_params(params)
+        for w in self.wires:
+            w['a'] = tuple(map(float,np.array(w['a']) + np.array([params_m.get('dx_m'), params_m.get('dy_m'), params_m.get('dz_m')])))
+            w['b'] = tuple(map(float,np.array(w['b']) + np.array([params_m.get('dx_m'), params_m.get('dy_m'), params_m.get('dz_m')])))
+
+    def rotate_ZtoY(self):
+        R = np.array([[1, 0, 0],[0,  0, 1],[0,  -1, 0]])
+        return self.rotate(R)
+    
+    def rotate_ZtoX(self):
+        R = np.array([[0, 0, 1],[0,  1, 0],[-1,  0, 0]])
+        return self.rotate(R)
+
+    def rotate_around_Z(self, angle_deg):
+        ca, sa = self.cos_sin(angle_deg)
+        R = np.array([[ca, -sa, 0],
+                      [sa, ca, 0],
+                      [0, 0, 1]])
+        return self.rotate(R)
+
+    def rotate_around_X(self, angle_deg):
+        ca, sa = self.cos_sin(angle_deg)
+        R = np.array([[1, 0, 0],
+                      [0, ca, -sa],
+                      [0, sa, ca]])
+        return self.rotate(R)
+
+    def rotate_around_Y(self, angle_deg):
+        ca, sa = self.cos_sin(angle_deg)
+        R = np.array([[ca, 0, sa],
+                      [0, 1, 0],
+                      [-sa, 0, ca]])
+        return self.rotate(R)
+
+    def cos_sin(self,angle_deg):
+        angle_rad = math.pi*angle_deg/180
+        ca = math.cos(angle_rad)
+        sa = math.sin(angle_rad)
+        return ca, sa
+    
+    def rotate(self, R):
+        for w in self.wires:
+            a = np.array(w['a'])
+            b = np.array(w['b'])
+            w['a'] = tuple(map(float, R @ a))
+            w['b'] = tuple(map(float, R @ b))
+
+    def connect_ends(self, other, tol=1e-3):
+        wires_to_add=[]
+        for ws in self.wires:
+            for es in [ws["a"], ws["b"]]:
+                for wo in other.wires:
+                    if (self.point_should_connect_to_wire(es,wo['a'],wo['b'],tol)):
+                        b = wo["b"]
+                        wo['b']=tuple(es)
+                        wires_to_add.append( (wo['iTag'], 0, *es, *b, wo['wr']) )
+                        break #(for efficiency only)
+        for params in wires_to_add:
+            other.add_wire(*params)
+
+    def point_should_connect_to_wire(self,P, A, B, tol=1e-6):
+        P = np.array(P, dtype=float)
+        A = np.array(A, dtype=float)
+        B = np.array(B, dtype=float)
+        AB = B - A
+        AP = P - A
+        AB_len = np.linalg.norm(AB)
+        # can't connect to a zero length wire using the splitting method
+        # but maybe should allow connecting by having the same co-ordinates
+        if AB_len == 0:
+            return False
+        
+        # Check perpendicular distance from wire axis
+        # if we aren't close enough to the wire axis to need to connect, return false
+        # NOTE: need to align tol with nec's check of volumes intersecting
+        perp_dist = np.linalg.norm(np.cross(AP, AB)) / AB_len
+        if perp_dist > tol: 
+            return False    
+
+        # We *are* close enough to the wire axis but if we're not between the ends, return false
+        t = np.dot(AP, AB) / (AB_len ** 2)
+        if (t<0 or t>1):
+            return False
+        
+        # if we are within 1mm of either end (wires are written to 3dp in m), return false
+        if ((np.linalg.norm(AP) < 0.001) or (np.linalg.norm(B-P) < 0.001)):
+            return False
+
+        return True
+
+    def point_on_object(self,geom_object, wire_index, alpha_wire):
+        if(wire_index> len(geom_object.wires)):
+            wire_index = len(geom_object.wires)
+            alpha_wire = 1.0
+        w = geom_object.wires[wire_index]
+        A = np.array(w["a"], dtype=float)
+        B = np.array(w["b"], dtype=float)
+        P = A + alpha_wire * (B-A)
+        return P
+
+
+
+#=================================================================================
+# Units processor
+#=================================================================================
+
+class units:
+    
+    _UNIT_FACTORS = {
+        "m": 1.0,
+        "mm": 1000.0,
+        "cm": 100.0,
+        "in": 39.3701,
+        "ft": 3.28084,
+    }
+
+    def __init__(self, default_unit: str = "m"):
+        if default_unit not in self._UNIT_FACTORS:
+            raise ValueError(f"Unsupported unit: {default_unit}")
+        self.default_unit = default_unit
+
+    def from_suffixed_params(self, params: dict, whitelist=[]) -> dict:
+        """Converts suffixed values like 'd_mm' to meters.
+
+        Output keys have '_m' suffix unless they already end with '_m',
+        in which case they are passed through unchanged (assumed meters).
+        """
+        
+        out = {}
+        names_seen = []
+        for key, value in params.items():
+    
+            if not isinstance(value, (int, float)):
+                continue  # skip nested dicts or other structures
+
+            name = key
+            suffix = ""
+            if "_" in name:
+                name, suffix = name.rsplit("_", 1)
+                
+            if(name in names_seen):
+                warnstr = f"Duplicate value of '{name}' seen: ignoring latest ({key} = {value})"
+                warnings.warn(warnstr)
+                continue
+
+            names_seen.append(name)
+
+            if suffix in self._UNIT_FACTORS:
+                # Convert value, output key with '_m' suffix
+                out[name + "_m"] = value / self._UNIT_FACTORS[suffix]
+                continue
+
+            if key in whitelist:
+                continue
+            
+            # fallback: no recognised suffix, assume metres
+            warnings.warn(f"No recognised units specified for {name}: '{suffix}' specified, metres assumed")
+            # output key gets '_m' suffix added
+            out[name + "_m"] = value
+
+        return out
+
+
+#=================================================================================
+# NEC Wrapper functions for writing .nec file and reading output
+#=================================================================================
 
 class NECModel:
     def __init__(self, working_dir, nec_exe_path, model_name = "Unnamed_Antennna", verbose=False):
         self.verbose = verbose
         self.working_dir = working_dir
         self.nec_exe = nec_exe_path
         self.nec_bat = working_dir + "\\nec.bat"
         self.nec_in = working_dir + "\\" + model_name +  ".nec"
         self.nec_out = working_dir + "\\" + model_name +  ".out"
         self.files_txt = working_dir + "\\files.txt"
         self.model_name = model_name
         self.model_text = ""
         self.LD_WIRECOND = ""
         self.FR_CARD = ""
         self.RP_CARD = ""
         self.GE_CARD = "GE 0\n"
         self.GN_CARD = ""
         self.GM_CARD = ""
         self.comments = ""
         self.EX_TAG = 999
         self.nSegs_per_wavelength = 40
         self.segLength_m = 0
         self.units = units()
         self.write_runner_files()
 
     def write_runner_files(self):
         for filepath, content in [
             (self.nec_bat, f"{self.nec_exe} < {self.files_txt} \n"),
             (self.files_txt, f"{self.nec_in}\n{self.nec_out}\n")
         ]:
             directory = os.path.dirname(filepath)
             if directory and not os.path.exists(directory):
                 os.makedirs(directory)  # create directory if it doesn't exist
             try:
                 with open(filepath, "w") as f:
                     f.write(content)
             except Exception as e:
                 print(f"Error writing file {filepath}: {e}")
 
 
     def set_wire_conductivity(self, sigma):
         self.LD_WIRECOND = f"LD 5 0 0 0 {sigma:.6f} \n"
 
     def set_frequency(self, MHz):
         self.FR_CARD = f"FR 0 1 0 0 {MHz:.3f} 0\n"
         lambda_m = 300/MHz
         self.segLength_m = lambda_m / self.nSegs_per_wavelength
         
     def set_gain_point(self, azimuth, elevation):
         self.RP_CARD = f"RP 0 1 1 1000 {90-elevation:.2f} {azimuth:.2f} 0 0\n"
 
     def set_gain_az_arc(self, azimuth_start, azimuth_stop, nPoints, elevation):
         if(nPoints<2):
             nPoints=2
         dAz = (azimuth_stop - azimuth_start) / (nPoints-1)
         self.RP_CARD = f"RP 0 1 {nPoints} 1000 {90-elevation:.2f} {azimuth:.2f} 0 {dAz:.2f}\n"
 
     def set_ground(self, eps_r, sigma, **params):
         """
             Sets the ground relative permitivity and conductivity. Currently limited to simple choices.
-            If eps_r = 1 and sigma = 0, nec is told to use no ground (free space model), and you may omit the origin height parameter
+            If eps_r = 1, nec is told to use no ground (free space model), and you may omit the origin height parameter
             If you don't call this function, free space will be assumed.
             Othewise you should set the origin height so that the antenna reference point X,Y,Z = (0,0,0) is set to be
             the specified distance above ground.
             Parameters:
                 eps_r (float): relative permittivity (relative dielectric constant) of the ground
                 sigma (float): conductivity of the ground in mhos/meter
                 origin_height_{units_string} (float): Height of antenna reference point X,Y,Z = (0,0,0)
         """
         if eps_r == 1.0:
             self.GE_CARD = "GE 0\n"
             self.GN_CARD = ""
             self.GM_CARD = "GM 0 0 0 0 0 0 0 0.000\n"
         else:
             origin_height_m = self.units.from_suffixed_params(params)['origin_height_m']
-            self.GE_CARD = "GE 1\n"
+            self.GE_CARD = "GE -1\n"
             self.GN_CARD = f"GN 2 0 0 0 {eps_r:.3f} {sigma:.3f} \n"
             self.GM_CARD = f"GM 0 0 0 0 0 0 0 {origin_height_m:.3f}\n"
 
     def start_geometry(self, comments="No comments specified"):
         # effectively *resets* the model, except that all of the parameters
         # set by set_ functions are still incorporated when the file is written
         self.comments = comments
         self.model_text = "CM " + comments + "\nCE\n"
         # TO DO: decide if 500 is the right tag to start at, and whether to limit # of loads
         self.LOAD_iTag = 500
         self.LOADS = []
 
     def place_series_RLC_load(self, geomObj, R_ohms, L_uH, C_pf, load_alpha_object=-1, load_wire_index=-1, load_alpha_wire=-1):
         """
             inserts a single segment containing a series RLC load into an existing geometry object
             see _place_feed_or_load for how to specify the position of the segment within the object
         """
         self.LOADS.append(f"LD 0 {self.LOAD_iTag} 0 0 {R_ohms} {L_uH * 1e-6} {C_pf * 1e-12}\n")
         self._place_feed_or_load(geomObj, self.LOAD_iTag, load_alpha_object, load_wire_index, load_alpha_wire)
         self.LOAD_iTag +=1
         
     def place_parallel_RLC_load(self, geomObj, R_ohms, L_uH, C_pf, load_alpha_object=-1, load_wire_index=-1, load_alpha_wire=-1):
         """
             inserts a single segment containing a parakllel RLC load into an existing geometry object
             see _place_feed_or_load for how to specify the position of the segment within the object
         """
         self.LOADS.append(f"LD 1 {self.LOAD_iTag} 0 0 {R_ohms} {L_uH * 1e-6} {C_pf * 1e-12}\n")
         self._place_feed_or_load(geomObj, self.LOAD_iTag, load_alpha_object, load_wire_index, load_alpha_wire)
         self.LOAD_iTag +=1
 
     def place_feed(self,  geomObj, feed_alpha_object=-1, feed_wire_index=-1, feed_alpha_wire=-1):
         """
             inserts a single segment containing the excitation point into an existing geometry object
             see _place_feed_or_load for how to specify the position of the segment within the object
         """
         self._place_feed_or_load(geomObj, self.EX_TAG, feed_alpha_object, feed_wire_index, feed_alpha_wire)
 
     def _place_feed_or_load(self, geomObj, item_iTag, item_alpha_object, item_wire_index, item_alpha_wire):
         """
             inserts a single segment with a specified iTag into an existing geometry object
             position within the object is specied as
             EITHER:
               item_alpha_object (range 0 to 1) as a parameter specifying the length of
                                 wire traversed to reach the item by following each wire in the object,
                                 divided by the length of all wires in the object
             OR:
               item_wire_index AND item_alpha_wire
               which specify the i'th wire in the n wires in the object, and the distance along that
               wire divided by that wire's length
         """
         wires = geomObj.get_wires()
         if(item_alpha_object >=0):
             item_wire_index = min(len(wires)-1,int(item_alpha_object*len(wires))) # 0 to nWires -1
             item_alpha_wire = item_alpha_object - item_wire_index
         w = wires[item_wire_index]       
 
         # calculate wire length vector AB, length a to b and distance from a to feed point
         A = np.array(w["a"], dtype=float)
         B = np.array(w["b"], dtype=float)
         AB = B-A
         wLen = np.linalg.norm(AB)
         feedDist = wLen * item_alpha_wire
 
         if (wLen <= self.segLength_m):
             # feed segment is all of this wire, so no need to split
             w['nS'] = 1
             w['iTag'] = item_iTag
         else:
             # split the wire AB into three wires: A to C, CD (feed segment), D to B
             nS1 = int(feedDist / self.segLength_m)              # no need for min of 1 as we always have the feed segment
             C = A + AB * (nS1 * self.segLength_m) / wLen        # feed segment end a
             D = A + AB * ((nS1+1) * self.segLength_m) / wLen    # feed segment end b
             nS2 = int((wLen-feedDist) / self.segLength_m)       # no need for min of 1 as we always have the feed segment
             # write results back to geomObj: modify existing wire to end at C, add feed segment CD and final wire DB
             # (nonzero nS field is preserved during segmentation in 'add')
             w['b'] = tuple(C)
             w['nS'] = nS1
             geomObj.add_wire(item_iTag , 1, *C, *D, w["wr"])
             geomObj.add_wire(w["iTag"] , nS2, *D, *B, w["wr"])
                 
     def add(self, geomObj):
         for w in geomObj.get_wires():
             A = np.array(w["a"], dtype=float)
             B = np.array(w["b"], dtype=float)
             if(w['nS'] == 0): # preserve pre-calculated segments
                 w['nS'] = 1+int(np.linalg.norm(B-A) / self.segLength_m)
             self.model_text += f"GW {w['iTag']} {w['nS']} "
             for v in A:
                 self.model_text += f"{v:.3f} "
             for v in B:
                 self.model_text += f"{v:.3f} "
             self.model_text += f"{w['wr']}\n"
 
     def finalise(self):
         self.model_text += self.GM_CARD
         self.model_text += self.GE_CARD
         self.model_text += self.GN_CARD
         self.model_text += "EK\n"
         self.model_text += self.LD_WIRECOND
         for LD in self.LOADS:
             self.model_text += LD
         self.model_text += f"EX 0 {self.EX_TAG} 1 0 1 0\n"
         self.model_text += self.FR_CARD
         self.model_text += self.RP_CARD
         self.model_text += "EN"
 
     def write_nec(self):
         self.finalise()
         with open(self.nec_in, "w") as f:
             f.write(self.model_text)
 
     def run_nec(self):
         subprocess.run([self.nec_bat], creationflags=subprocess.CREATE_NO_WINDOW)
 
     def gains(self):
         try:
             with open(self.nec_out) as f:
                 while "RADIATION PATTERNS" not in f.readline():
                     pass
                 for _ in range(5):
                     l = f.readline()
                 if self.verbose:
                     print("Gains line:", l.strip())
         except (RuntimeError, ValueError):
             raise ValueError(f"Something went wrong reading gains from {nec_out}")
 
         return {
             "v_gain": float(l[21:29]),
             "h_gain": float(l[29:37]),
             "total": float(l[37:45]),
         }
 
     def h_gain(self):
         return self.gains()['h_gain']
 
     def v_gain(self):
         return self.gains()['v_gain']
 
     def tot_gain(self):
         return self.gains()['total']
 
     def vswr(self):
         try:
             with open(self.nec_out) as f:
                 while "ANTENNA INPUT PARAMETERS" not in f.readline():
                     pass
                 for _ in range(4):
                     l = f.readline()
                 if self.verbose:
                     print("Z line:", l.strip())
                 r = float(l[60:72])
                 x = float(l[72:84])
         except (RuntimeError, ValueError):
             raise ValueError(f"Something went wrong reading input impedance from {nec_out}")
 
         z_in = r + x * 1j
         z0 = 50
         gamma = (z_in - z0) / (z_in + z0)
         return (1 + abs(gamma)) / (1 - abs(gamma))
+
+
diff --git a/necbol/nec_wrapper.py b/necbol/nec_wrapper.py
deleted file mode 100644
index f98afc1..0000000
--- a/necbol/nec_wrapper.py
+++ /dev/null
@@ -1,264 +0,0 @@
-"""
-This file is part of the "NECBOL Plain Language Python NEC Runner"
-Copyright (c) 2025 Alan Robinson G1OJS
-
-MIT License
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-"""
-
-import subprocess
-import os
-import numpy as np
-from necbol.units import units
-
-class NECModel:
-    def __init__(self, working_dir, nec_exe_path, model_name = "Unnamed_Antennna", verbose=False):
-        self.verbose = verbose
-        self.working_dir = working_dir
-        self.nec_exe = nec_exe_path
-        self.nec_bat = working_dir + "\\nec.bat"
-        self.nec_in = working_dir + "\\" + model_name +  ".nec"
-        self.nec_out = working_dir + "\\" + model_name +  ".out"
-        self.files_txt = working_dir + "\\files.txt"
-        self.model_name = model_name
-        self.model_text = ""
-        self.LD_WIRECOND = ""
-        self.FR_CARD = ""
-        self.RP_CARD = ""
-        self.GE_CARD = "GE 0\n"
-        self.GN_CARD = ""
-        self.GM_CARD = ""
-        self.comments = ""
-        self.EX_TAG = 999
-        self.nSegs_per_wavelength = 40
-        self.segLength_m = 0
-        self.units = units()
-        self.write_runner_files()
-
-    def write_runner_files(self):
-        for filepath, content in [
-            (self.nec_bat, f"{self.nec_exe} < {self.files_txt} \n"),
-            (self.files_txt, f"{self.nec_in}\n{self.nec_out}\n")
-        ]:
-            directory = os.path.dirname(filepath)
-            if directory and not os.path.exists(directory):
-                os.makedirs(directory)  # create directory if it doesn't exist
-            try:
-                with open(filepath, "w") as f:
-                    f.write(content)
-            except Exception as e:
-                print(f"Error writing file {filepath}: {e}")
-
-
-    def set_wire_conductivity(self, sigma):
-        self.LD_WIRECOND = f"LD 5 0 0 0 {sigma:.6f} \n"
-
-    def set_frequency(self, MHz):
-        self.FR_CARD = f"FR 0 1 0 0 {MHz:.3f} 0\n"
-        lambda_m = 300/MHz
-        self.segLength_m = lambda_m / self.nSegs_per_wavelength
-        
-    def set_gain_point(self, azimuth, elevation):
-        self.RP_CARD = f"RP 0 1 1 1000 {90-elevation:.2f} {azimuth:.2f} 0 0\n"
-
-    def set_gain_az_arc(self, azimuth_start, azimuth_stop, nPoints, elevation):
-        if(nPoints<2):
-            nPoints=2
-        dAz = (azimuth_stop - azimuth_start) / (nPoints-1)
-        self.RP_CARD = f"RP 0 1 {nPoints} 1000 {90-elevation:.2f} {azimuth:.2f} 0 {dAz:.2f}\n"
-
-    def set_ground(self, eps_r, sigma, **params):
-        """
-            Sets the ground relative permitivity and conductivity. Currently limited to simple choices.
-            If eps_r = 1 and sigma = 0, nec is told to use no ground (free space model), and you may omit the origin height parameter
-            If you don't call this function, free space will be assumed.
-            Othewise you should set the origin height so that the antenna reference point X,Y,Z = (0,0,0) is set to be
-            the specified distance above ground.
-            Parameters:
-                eps_r (float): relative permittivity (relative dielectric constant) of the ground
-                sigma (float): conductivity of the ground in mhos/meter
-                origin_height_{units_string} (float): Height of antenna reference point X,Y,Z = (0,0,0)
-        """
-        if eps_r == 1.0:
-            self.GE_CARD = "GE 0\n"
-            self.GN_CARD = ""
-            self.GM_CARD = "GM 0 0 0 0 0 0 0 0.000\n"
-        else:
-            origin_height_m = self.units.from_suffixed_params(params)['origin_height_m']
-            self.GE_CARD = "GE 1\n"
-            self.GN_CARD = f"GN 2 0 0 0 {eps_r:.3f} {sigma:.3f} \n"
-            self.GM_CARD = f"GM 0 0 0 0 0 0 0 {origin_height_m:.3f}\n"
-
-    def start_geometry(self, comments="No comments specified"):
-        # effectively *resets* the model, except that all of the parameters
-        # set by set_ functions are still incorporated when the file is written
-        self.comments = comments
-        self.model_text = "CM " + comments + "\nCE\n"
-        # TO DO: decide if 500 is the right tag to start at, and whether to limit # of loads
-        self.LOAD_iTag = 500
-        self.LOADS = []
-
-    def place_series_RLC_load(self, geomObj, R_ohms, L_uH, C_pf, load_alpha_object=-1, load_wire_index=-1, load_alpha_wire=-1):
-        """
-            inserts a single segment containing a series RLC load into an existing geometry object
-            see _place_feed_or_load for how to specify the position of the segment within the object
-        """
-        self.LOADS.append(f"LD 0 {self.LOAD_iTag} 0 0 {R_ohms} {L_uH * 1e-6} {C_pf * 1e-12}\n")
-        self._place_feed_or_load(geomObj, self.LOAD_iTag, load_alpha_object, load_wire_index, load_alpha_wire)
-        self.LOAD_iTag +=1
-        
-    def place_parallel_RLC_load(self, geomObj, R_ohms, L_uH, C_pf, load_alpha_object=-1, load_wire_index=-1, load_alpha_wire=-1):
-        """
-            inserts a single segment containing a parakllel RLC load into an existing geometry object
-            see _place_feed_or_load for how to specify the position of the segment within the object
-        """
-        self.LOADS.append(f"LD 1 {self.LOAD_iTag} 0 0 {R_ohms} {L_uH * 1e-6} {C_pf * 1e-12}\n")
-        self._place_feed_or_load(geomObj, self.LOAD_iTag, load_alpha_object, load_wire_index, load_alpha_wire)
-        self.LOAD_iTag +=1
-
-    def place_feed(self,  geomObj, feed_alpha_object=-1, feed_wire_index=-1, feed_alpha_wire=-1):
-        """
-            inserts a single segment containing the excitation point into an existing geometry object
-            see _place_feed_or_load for how to specify the position of the segment within the object
-        """
-        self._place_feed_or_load(geomObj, self.EX_TAG, feed_alpha_object, feed_wire_index, feed_alpha_wire)
-
-    def _place_feed_or_load(self, geomObj, item_iTag, item_alpha_object, item_wire_index, item_alpha_wire):
-        """
-            inserts a single segment with a specified iTag into an existing geometry object
-            position within the object is specied as
-            EITHER:
-              item_alpha_object (range 0 to 1) as a parameter specifying the length of
-                                wire traversed to reach the item by following each wire in the object,
-                                divided by the length of all wires in the object
-            OR:
-              item_wire_index AND item_alpha_wire
-              which specify the i'th wire in the n wires in the object, and the distance along that
-              wire divided by that wire's length
-        """
-        wires = geomObj.get_wires()
-        if(item_alpha_object >=0):
-            item_wire_index = min(len(wires)-1,int(item_alpha_object*len(wires))) # 0 to nWires -1
-            item_alpha_wire = item_alpha_object - item_wire_index
-        w = wires[item_wire_index]       
-
-        # calculate wire length vector AB, length a to b and distance from a to feed point
-        A = np.array(w["a"], dtype=float)
-        B = np.array(w["b"], dtype=float)
-        AB = B-A
-        wLen = np.linalg.norm(AB)
-        feedDist = wLen * item_alpha_wire
-
-        if (wLen <= self.segLength_m):
-            # feed segment is all of this wire, so no need to split
-            w['nS'] = 1
-            w['iTag'] = item_iTag
-        else:
-            # split the wire AB into three wires: A to C, CD (feed segment), D to B
-            nS1 = int(feedDist / self.segLength_m)              # no need for min of 1 as we always have the feed segment
-            C = A + AB * (nS1 * self.segLength_m) / wLen        # feed segment end a
-            D = A + AB * ((nS1+1) * self.segLength_m) / wLen    # feed segment end b
-            nS2 = int((wLen-feedDist) / self.segLength_m)       # no need for min of 1 as we always have the feed segment
-            # write results back to geomObj: modify existing wire to end at C, add feed segment CD and final wire DB
-            # (nonzero nS field is preserved during segmentation in 'add')
-            w['b'] = tuple(C)
-            w['nS'] = nS1
-            geomObj.add_wire(item_iTag , 1, *C, *D, w["wr"])
-            geomObj.add_wire(w["iTag"] , nS2, *D, *B, w["wr"])
-                
-    def add(self, geomObj):
-        for w in geomObj.get_wires():
-            A = np.array(w["a"], dtype=float)
-            B = np.array(w["b"], dtype=float)
-            if(w['nS'] == 0): # preserve pre-calculated segments
-                w['nS'] = 1+int(np.linalg.norm(B-A) / self.segLength_m)
-            self.model_text += f"GW {w['iTag']} {w['nS']} "
-            for v in A:
-                self.model_text += f"{v:.3f} "
-            for v in B:
-                self.model_text += f"{v:.3f} "
-            self.model_text += f"{w['wr']}\n"
-
-    def finalise(self):
-        self.model_text += self.GM_CARD
-        self.model_text += self.GE_CARD
-        self.model_text += self.GN_CARD
-        self.model_text += "EK\n"
-        self.model_text += self.LD_WIRECOND
-        for LD in self.LOADS:
-            self.model_text += LD
-        self.model_text += f"EX 0 {self.EX_TAG} 1 0 1 0\n"
-        self.model_text += self.FR_CARD
-        self.model_text += self.RP_CARD
-        self.model_text += "EN"
-
-    def write_nec(self):
-        self.finalise()
-        with open(self.nec_in, "w") as f:
-            f.write(self.model_text)
-
-    def run_nec(self):
-        subprocess.run([self.nec_bat], creationflags=subprocess.CREATE_NO_WINDOW)
-
-    def gains(self):
-        try:
-            with open(self.nec_out) as f:
-                while "RADIATION PATTERNS" not in f.readline():
-                    pass
-                for _ in range(5):
-                    l = f.readline()
-                if self.verbose:
-                    print("Gains line:", l.strip())
-        except (RuntimeError, ValueError):
-            raise ValueError(f"Something went wrong reading gains from {nec_out}")
-
-        return {
-            "v_gain": float(l[21:29]),
-            "h_gain": float(l[29:37]),
-            "total": float(l[37:45]),
-        }
-
-    def h_gain(self):
-        return self.gains()['h_gain']
-
-    def v_gain(self):
-        return self.gains()['v_gain']
-
-    def tot_gain(self):
-        return self.gains()['total']
-
-    def vswr(self):
-        try:
-            with open(self.nec_out) as f:
-                while "ANTENNA INPUT PARAMETERS" not in f.readline():
-                    pass
-                for _ in range(4):
-                    l = f.readline()
-                if self.verbose:
-                    print("Z line:", l.strip())
-                r = float(l[60:72])
-                x = float(l[72:84])
-        except (RuntimeError, ValueError):
-            raise ValueError(f"Something went wrong reading input impedance from {nec_out}")
-
-        z_in = r + x * 1j
-        z0 = 50
-        gamma = (z_in - z0) / (z_in + z0)
-        return (1 + abs(gamma)) / (1 - abs(gamma))
diff --git a/necbol/optimisers.py b/necbol/optimisers.py
index 3d6d9d3..d5a41f2 100644
--- a/necbol/optimisers.py
+++ b/necbol/optimisers.py
@@ -23,97 +23,107 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 """
 
+
 import random, sys
 
 class RandomOptimiser:
     def __init__(self, build_fn, param_init, cost_fn,
                  bounds={}, delta_init=0.2, stall_limit=50, max_iter=250, min_delta=0.001):
         self.build_fn = build_fn
         self.param_names = list(param_init.keys())
         self.x_baseline = param_init.copy()
         self.bounds = bounds
         self.cost_fn = cost_fn
         self.delta_x = delta_init
         self.min_delta = min_delta
         self.stall_limit = stall_limit
         self.max_iter = max_iter
 
     def format_params(self, params):
         s="{"
         for k, v in params.items():
             s = s + f"'{k}': {v:.2f}, "
         return s[0:-2]+"}"
 
     def same_line_print(self,text):
-        sys.stdout.write(f"\r{text}        ")
+        sys.stdout.write(f"\r{text}          ")
         sys.stdout.flush()
 
     def random_variation(self, x):
         x_new = x.copy()
         for name in self.param_names:
             factor = 1 + random.uniform(-self.delta_x, self.delta_x)
             val = x[name] * factor
             x_new[name] = val
             if(name in self.bounds):
                 minv, maxv = self.bounds[name]
                 x_new[name] = max(min(x_new[name], maxv), minv)
         return x_new
 
-    def optimise(self, model,  verbose=False):
+    def optimise(self, model,  verbose=False, tty=True):
         best_params = self.x_baseline.copy()
         best_model = self.build_fn(model, **best_params)
         best_model.write_nec()
         best_model.run_nec()
         result = self.cost_fn(best_model)
         best_cost = result['cost']
         best_info = result['info']
         stall_count = 0
         print("\nSTARTING optimiser. Press CTRL-C to stop")
         initial_message = f"[] INITIAL: {best_info} with {self.format_params(best_params)}"
         print(initial_message)
 
         try:
             for i in range(self.max_iter):
                 test_params = self.random_variation(best_params)
                 test_model = self.build_fn(model, **test_params)
                 test_model.write_nec()
                 test_model.run_nec()
                 result = self.cost_fn(test_model)
                 test_cost = result['cost']
                 test_info = result['info']
 
                 if test_cost < best_cost:
                     best_cost = test_cost
                     best_params = test_params
                     best_info = test_info
                     stall_count = 0
+                    if(not tty):
+                        print("")
                     self.same_line_print(f"[{i}] IMPROVED: {best_info} with {self.format_params(best_params)}")
                     print("")
                 else:
                     stall_count += 1
-                    self.same_line_print(f"[{i}] {test_info}")
+                    if(tty):
+                        self.same_line_print(f"[{i}] {test_info}")
+                    else:
+                        sys.stdout.write(".")
 
                 if stall_count >= self.stall_limit:
                     self.delta_x /= 2
                     if(self.delta_x < self.min_delta):
+                        if(not tty):
+                            print("")
                         self.same_line_print(f"[{i}] Delta below minimum")
                         print("")
                         break
                     stall_count = 0
+                    if(not tty):
+                        print("")
                     self.same_line_print(f"[{i}] STALLED: Reducing delta to {self.delta_x}")
                     print("")
 
         except KeyboardInterrupt:
             print("\nINTERRUPTED by user input")
             
         best_model = self.build_fn(model, **best_params)
         best_model.write_nec()
         best_model.run_nec()
         result = self.cost_fn(best_model)
         final_info = result['info']
         print("\nFINISHED optimising\n")
         print("# Optimiser Results (copy and paste into your antenna file for reference). \nNote that you can copy the information between the {} to paste in as your new starting parameters.)")
         print("# "+ initial_message)
         print(f"# []   FINAL: {final_info} with {self.format_params(best_params)}")
         
         return best_params, final_info
diff --git a/necbol/units.py b/necbol/units.py
deleted file mode 100644
index 350013b..0000000
--- a/necbol/units.py
+++ /dev/null
@@ -1,85 +0,0 @@
-"""
-This file is part of the "NECBOL Plain Language Python NEC Runner"
-Copyright (c) 2025 Alan Robinson G1OJS
-
-MIT License
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-"""
-
-import warnings
-
-class units:
-    
-    _UNIT_FACTORS = {
-        "m": 1.0,
-        "mm": 1000.0,
-        "cm": 100.0,
-        "in": 39.3701,
-        "ft": 3.28084,
-    }
-
-    def __init__(self, default_unit: str = "m"):
-        if default_unit not in self._UNIT_FACTORS:
-            raise ValueError(f"Unsupported unit: {default_unit}")
-        self.default_unit = default_unit
-
-    def from_suffixed_params(self, params: dict, whitelist=[]) -> dict:
-        """Converts suffixed values like 'd_mm' to meters.
-
-        Output keys have '_m' suffix unless they already end with '_m',
-        in which case they are passed through unchanged (assumed meters).
-        """
-        
-        out = {}
-        names_seen = []
-        for key, value in params.items():
-    
-            if not isinstance(value, (int, float)):
-                continue  # skip nested dicts or other structures
-
-            name = key
-            suffix = ""
-            if "_" in name:
-                name, suffix = name.rsplit("_", 1)
-                
-            if(name in names_seen):
-                warnstr = f"Duplicate value of '{name}' seen: ignoring latest ({key} = {value})"
-                warnings.warn(warnstr)
-                continue
-
-            names_seen.append(name)
-
-            if suffix in self._UNIT_FACTORS:
-                # Convert value, output key with '_m' suffix
-                out[name + "_m"] = value / self._UNIT_FACTORS[suffix]
-                continue
-
-            if key in whitelist:
-                continue
-            
-            # fallback: no recognised suffix, assume metres
-            warnings.warn(f"No recognised units specified for {name}: '{suffix}' specified, metres assumed")
-            # output key gets '_m' suffix added
-            out[name + "_m"] = value
-
-        return out
-
-
-
